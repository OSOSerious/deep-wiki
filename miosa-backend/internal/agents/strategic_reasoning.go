// Package agents
// strategic_reasoning.go â€” Three-of-Thoughts (strategic reasoning) middleware for Agents.
//
// PURPOSE
//   This middleware wraps any Agent with an additional pre-execution reasoning step.
//   Before running the actual agent logic, it generates multiple alternative strategies,
//   selects the most promising one, and injects it into the execution context.
//
// DESIGN GOALS
//   - Decoupled: No direct dependency on orchestrator internals.
//   - Pluggable: Any reasoning engine (LLM, rules, hybrid) can implement StrategicReasoner.
//   - Non-blocking: If reasoning fails, gracefully fallback to normal execution.
//   - Context-driven: Chosen strategy accessible to wrapped agent via context helper.
package agents

import (
    "context"
    "encoding/json"
    "errors"
    "fmt"
    "strings"
    "time"
)

//
// ===== Strategy data structure =====
//

// StrategyNode represents a single strategic approach generated by the reasoning engine.
type StrategyNode struct {
    Idea        string            `json:"idea"`
    Steps       []string          `json:"steps,omitempty"`
    Pros        []string          `json:"pros,omitempty"`
    Cons        []string          `json:"cons,omitempty"`
    Risks       []string          `json:"risks,omitempty"`
    Confidence  float64           `json:"confidence"`
    Cost        string            `json:"cost,omitempty"`
    EstDuration string            `json:"estDuration,omitempty"`
    Metadata    map[string]string `json:"metadata,omitempty"`
}

//
// ===== Reasoner interface =====
//

// StrategicReasoner defines how strategies are generated and selected.
type StrategicReasoner interface {
    GenerateThoughtTree(ctx context.Context, task Task) ([]StrategyNode, error)
    SelectBestStrategy(nodes []StrategyNode) StrategyNode
    Name() string
}

//
// ===== Strategic Executor =====
//

// StrategicExecutor decorates an Agent to add a reasoning step before execution.
type StrategicExecutor struct {
    Wrapped       Agent
    Reasoner      StrategicReasoner
    MinCandidates int
}

func (se *StrategicExecutor) GetType() AgentType {
    return se.Wrapped.GetType()
}

func (se *StrategicExecutor) GetCapabilities() []Capability {
    return se.Wrapped.GetCapabilities()
}

func (se *StrategicExecutor) GetDescription() string {
    return se.Wrapped.GetDescription()
}

func (se *StrategicExecutor) Execute(ctx context.Context, task Task) (*Result, error) {
    if se.Reasoner == nil {
        return se.Wrapped.Execute(ctx, task)
    }

    strategies, err := se.Reasoner.GenerateThoughtTree(ctx, task)
    if err != nil || len(strategies) == 0 {
        // Fail soft: proceed without strategic injection
        return se.Wrapped.Execute(ctx, task)
    }

    if se.MinCandidates > 0 && len(strategies) < se.MinCandidates {
        return se.Wrapped.Execute(ctx, task)
    }

    best := se.Reasoner.SelectBestStrategy(strategies)
    ctx = WithChosenStrategy(ctx, best)

    return se.Wrapped.Execute(ctx, task)
}

//
// ===== Context helpers =====
//

type strategyCtxKey struct{}

func WithChosenStrategy(ctx context.Context, s StrategyNode) context.Context {
    return context.WithValue(ctx, strategyCtxKey{}, s)
}

func ChosenStrategyFromCtx(ctx context.Context) (StrategyNode, bool) {
    v := ctx.Value(strategyCtxKey{})
    s, ok := v.(StrategyNode)
    return s, ok
}

//
// ===== Generic ChatClient interface =====
//

// ChatMessage defines a role-content pair for prompting a reasoning engine.
type ChatMessage struct {
    Role    string
    Content string
}

// ChatOptions defines generic options for an LLM or similar engine.
type ChatOptions struct {
    Model       string
    Temperature float32
    MaxTokens   int
}

// ChatClient abstracts the interaction with an AI/LLM provider.
type ChatClient interface {
    Chat(ctx context.Context, messages []ChatMessage, opts ChatOptions) (string, error)
}

//
// ===== Default LLM-based reasoner implementation =====
//

type DefaultStrategicReasonerConfig struct {
    Client        ChatClient
    Model         string
    Temperature   float32
    MaxTokens     int
    SystemPrompt  string
    TaskText      func(Task) string
    MinCandidates int
    MaxCandidates int
}

type DefaultStrategicReasoner struct {
    cfg DefaultStrategicReasonerConfig
}

func NewDefaultStrategicReasoner(cfg DefaultStrategicReasonerConfig) *DefaultStrategicReasoner {
    if cfg.Model == "" {
        cfg.Model = "reasoner-default"
    }
    if cfg.MaxTokens == 0 {
        cfg.MaxTokens = 1024
    }
    if cfg.Temperature == 0 {
        cfg.Temperature = 0.7
    }
    if cfg.MinCandidates <= 0 {
        cfg.MinCandidates = 3
    }
    if cfg.MaxCandidates <= 0 {
        cfg.MaxCandidates = 3
    }
    return &DefaultStrategicReasoner{cfg: cfg}
}

func (r *DefaultStrategicReasoner) Name() string {
    return "default-strategic-reasoner"
}

func (r *DefaultStrategicReasoner) GenerateThoughtTree(ctx context.Context, task Task) ([]StrategyNode, error) {
    if r.cfg.Client == nil {
        return nil, errors.New("missing ChatClient")
    }

    taskText := fmt.Sprintf("%+v", task)
    if r.cfg.TaskText != nil {
        taskText = r.cfg.TaskText(task)
    }

    sysPrompt := strings.TrimSpace(r.cfg.SystemPrompt)
    if sysPrompt == "" {
        sysPrompt = "You are an expert in tactical and strategic problem solving. Generate actionable, diverse strategies."
    }

    userPrompt := fmt.Sprintf(
        `Generate %d-%d distinct strategies for the following task.
Respond ONLY with a valid JSON array; no markdown or extra commentary.
Schema:
{
 "idea": "...",
 "steps": ["..."],
 "pros": ["..."],
 "cons": ["..."],
 "risks": ["..."],
 "confidence": 0.0-1.0,
 "cost": "...",
 "estDuration": "...",
 "metadata": {"key":"value"}
}

Task:
%s`,
        r.cfg.MinCandidates, r.cfg.MaxCandidates, taskText,
    )

    ctx, cancel := context.WithTimeout(ctx, 40*time.Second)
    defer cancel()

    raw, err := r.cfg.Client.Chat(ctx,
        []ChatMessage{
            {Role: "system", Content: sysPrompt},
            {Role: "user", Content: userPrompt},
        },
        ChatOptions{
            Model:       r.cfg.Model,
            Temperature: r.cfg.Temperature,
            MaxTokens:   r.cfg.MaxTokens,
        },
    )
    if err != nil {
        return nil, err
    }

    clean := stripJSONFences(raw)

    var nodes []StrategyNode
    if err := json.Unmarshal([]byte(clean), &nodes); err != nil {
        // Attempt alternate parse if model returns {"strategies":[...]}
        var w struct {
            Strategies []StrategyNode `json:"strategies"`
        }
        if err2 := json.Unmarshal([]byte(clean), &w); err2 != nil || len(w.Strategies) == 0 {
            return nil, fmt.Errorf("failed to parse strategies: %w", err)
        }
        nodes = w.Strategies
    }

    for i := range nodes {
        nodes[i].Idea = strings.TrimSpace(nodes[i].Idea)
        if nodes[i].Metadata == nil {
            nodes[i].Metadata = map[string]string{}
        }
        if nodes[i].Confidence < 0 {
            nodes[i].Confidence = 0
        }
        if nodes[i].Confidence > 1 {
            nodes[i].Confidence = 1
        }
    }

    return nodes, nil
}

func (r *DefaultStrategicReasoner) SelectBestStrategy(nodes []StrategyNode) StrategyNode {
    if len(nodes) == 0 {
        return StrategyNode{}
    }
    best := nodes[0]
    for _, n := range nodes[1:] {
        if n.Confidence > best.Confidence {
            best = n
        } else if n.Confidence == best.Confidence {
            if len(n.Steps) > 0 && len(n.Steps) < len(best.Steps) {
                best = n
            } else if len(n.Risks) < len(best.Risks) {
                best = n
            }
        }
    }
    return best
}

//
// ===== Utility functions =====
//

func NewStrategicExecutor(agent Agent, reasoner StrategicReasoner, minCandidates int) *StrategicExecutor {
    return &StrategicExecutor{
        Wrapped:       agent,
        Reasoner:      reasoner,
        MinCandidates: minCandidates,
    }
}

func stripJSONFences(s string) string {
    out := strings.TrimSpace(s)
    if strings.HasPrefix(out, "```") {
        out = strings.TrimPrefix(out, "```")
        out = strings.TrimSpace(out)
        if strings.HasPrefix(strings.ToLower(out), "json") {
            out = strings.TrimSpace(out[len("json"):])
        }
        if idx := strings.LastIndex(out, "```"); idx >= 0 {
            out = out[:idx]
        }
    }
    return strings.TrimSpace(out)
}
