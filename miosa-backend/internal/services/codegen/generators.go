// Package codegen provides a robust, extensible backbone for cross-language
// code generation. It defines contracts (Schema, Entity, Field, Relation),
// target registration, orchestration with concurrency, options, and concrete
// generator implementations that emit usable models/specs for multiple targets.
//
// This file is production-ready and integrates directly with a schema.go that
// implements these interfaces. Generators here are self-contained (no template
// engine) and produce deterministic artifacts suitable for CI caching.
package codegen

import (
    "bytes"
    "context"
    "encoding/json"
    "errors"
    "fmt"
    "hash/fnv"
    "io/fs"
    "path/filepath"
    "sort"
    "strings"
    "sync"
    "time"
)

// -----------------------------------------------------------------------------
// Constants and defaults
// -----------------------------------------------------------------------------

const (
    DefaultPermissions fs.FileMode = 0o644
    GeneratedNotice                = "// Code generated by MIOSA codegen; DO NOT EDIT.\n"
    DefaultMaxParallel             = 4
)

// -----------------------------------------------------------------------------
// Schema contracts (to be implemented in your schema.go)
// -----------------------------------------------------------------------------

type Schema interface {
    Version() string
    Entities() []Entity
    FindEntity(name string) (Entity, bool)
}

type Entity interface {
    Name() string
    Table() string
    Fields() []Field
    Relations() []Relation
    Doc() string
}

type Field interface {
    Name() string
    Column() string
    Kind() string           // "string","int32","int64","float32","float64","decimal","bool","datetime","date","time","uuid","bytes","json",...
    Format() string         // Optional format hint (e.g., "email","uri","date-time")
    Nullable() bool
    PrimaryKey() bool
    Unique() bool
    Default() (string, bool)
    MaxLen() (int, bool)
    ScalePrecision() (scale int, precision int, ok bool)
    Tags() map[string]string
    Doc() string
}

type Relation interface {
    Type() string // "one-to-one","one-to-many","many-to-many",...
    From() (entity string, field string)
    To() (entity string, field string)
    Through() (table string, ok bool)
    Doc() string
}

// -----------------------------------------------------------------------------
// Targets, Options, Artifacts, Results
// -----------------------------------------------------------------------------

type Target string

const (
    TargetGo      Target = "go"
    TargetPy      Target = "py"
    TargetTS      Target = "ts"
    TargetJS      Target = "js"
    TargetJava    Target = "java"
    TargetCSharp  Target = "csharp"
    TargetKotlin  Target = "kotlin"
    TargetSwift   Target = "swift"
    TargetDart    Target = "dart"
    TargetPHP     Target = "php"
    TargetRuby    Target = "ruby"
    TargetRust    Target = "rust"
    TargetScala   Target = "scala"
    TargetCPP     Target = "cpp"
    TargetSQL     Target = "sql"
    TargetJSON    Target = "json"
    TargetGraphQL Target = "graphql"
    TargetOpenAPI Target = "openapi"
    TargetProto   Target = "proto"
)

type Options struct {
    // General
    OutDir         string
    Preamble       string
    Overwrite      bool
    EmitDocs       bool
    MaxParallel    int
    Newline        string // "", "\n", or "\r\n"
    Indent         string // "  " or "\t"
    IncludeTargets []Target

    // Go
    GoPackage     string
    GoBuildTags   []string
    OmitEmptyJSON bool

    // Python
    PyModuleBase  string
    PyUsePydantic bool

    // TypeScript
    TSOutDir string
    TSJSDoc  bool

    // Java
    JavaOutDir string
    JavaPkg    string

    // C#
    CsOutDir string
    CsNs     string

    // Kotlin
    KtOutDir string
    KtPkg    string

    // Swift
    SwiftOutDir string
    SwiftModule string

    // Dart
    DartOutDir string
    DartPkg    string

    // PHP
    PhpOutDir string
    PhpNs     string

    // Ruby
    RubyOutDir string
    RubyGem    string

    // Rust
    RustOutDir string
    RustCrate  string

    // Scala
    ScalaOutDir string
    ScalaPkg    string

    // C++
    CppOutDir string
    CppNs     string

    // SQL
    SQLOutDir  string
    SQLDialect string // "postgres","mysql","sqlite",...

    // JSON
    JSONOutDir string
    JSONIndent string

    // GraphQL
    GQLOutDir string

    // OpenAPI
    OpenAPIOutDir string
    OpenAPIVer    string // "3.0.3","3.1.0"

    // Proto
    ProtoOutDir string
    ProtoPkg    string
    ProtoSyntax string // "proto3"
}

type Artifact struct {
    Path      string
    Data      []byte
    Mode      fs.FileMode
    Generator string
    Target    Target
}

type Result struct {
    Artifacts     []Artifact
    Diagnostics   []string
    Duration      time.Duration
    SchemaVersion string
    Hash          uint64
}

// -----------------------------------------------------------------------------
// Generator interface
// -----------------------------------------------------------------------------

type Generator interface {
    Name() string
    Targets() []Target
    Generate(ctx context.Context, sch Schema, opts Options) ([]Artifact, error)
}

// -----------------------------------------------------------------------------
// Registry and orchestration
// -----------------------------------------------------------------------------

var (
    regMu      sync.RWMutex
    registry   = map[string]Generator{}
    targetSets = map[Target][]string{}
)

func Register(gen Generator) {
    if gen == nil {
        panic("codegen: Register(nil)")
    }
    regMu.Lock()
    defer regMu.Unlock()
    if _, exists := registry[gen.Name()]; exists {
        panic("codegen: generator already registered: " + gen.Name())
    }
    registry[gen.Name()] = gen
    for _, t := range gen.Targets() {
        targetSets[t] = append(targetSets[t], gen.Name())
    }
}

func Get(name string) (Generator, bool) {
    regMu.RLock()
    defer regMu.RUnlock()
    g, ok := registry[name]
    return g, ok
}

func List() []string {
    regMu.RLock()
    defer regMu.RUnlock()
    names := make([]string, 0, len(registry))
    for n := range registry {
        names = append(names, n)
    }
    sort.Strings(names)
    return names
}

func ListByTarget(t Target) []string {
    regMu.RLock()
    defer regMu.RUnlock()
    names := append([]string(nil), targetSets[t]...)
    sort.Strings(names)
    return names
}

var (
    ErrDuplicatePath   = errors.New("codegen: duplicate artifact path")
    ErrInvalidSchema   = errors.New("codegen: invalid schema")
    ErrInvalidOptions  = errors.New("codegen: invalid options")
    ErrGeneratorFailed = errors.New("codegen: generator failed")
)

func GenerateAll(ctx context.Context, sch Schema, generatorNames []string, opts Options) (Result, error) {
    start := time.Now()

    if err := ValidateSchema(sch); err != nil {
        return Result{}, fmt.Errorf("%w: %v", ErrInvalidSchema, err)
    }
    if err := ValidateOptions(opts); err != nil {
        return Result{}, fmt.Errorf("%w: %v", ErrInvalidOptions, err)
    }

    if len(generatorNames) == 0 {
        generatorNames = List()
    }
    sort.Strings(generatorNames)

    maxPar := opts.MaxParallel
    if maxPar <= 0 {
        maxPar = DefaultMaxParallel
    }

    type taskRes struct {
        arts []Artifact
        name string
        err  error
    }

    wg := sync.WaitGroup{}
    sem := make(chan struct{}, maxPar)
    out := make(chan taskRes, len(generatorNames))

    for _, name := range generatorNames {
        gen, ok := Get(name)
        if !ok {
            return Result{}, fmt.Errorf("codegen: generator not found: %s", name)
        }
        if len(opts.IncludeTargets) > 0 && !generatorTargetsAllowed(gen, opts.IncludeTargets) {
            continue
        }
        wg.Add(1)
        sem <- struct{}{}
        go func(g Generator) {
            defer wg.Done()
            defer func() { <-sem }()
            arts, err := g.Generate(ctx, sch, opts)
            out <- taskRes{arts: arts, name: g.Name(), err: err}
        }(gen)
    }

    go func() {
        wg.Wait()
        close(out)
    }()

    var diagnostics []string
    pathIndex := map[string]string{}
    var artifacts []Artifact

    for r := range out {
        if r.err != nil {
            return Result{}, fmt.Errorf("%w: %s: %v", ErrGeneratorFailed, r.name, r.err)
        }
        for _, a := range r.arts {
            if strings.TrimSpace(a.Path) == "" {
                diagnostics = append(diagnostics, fmt.Sprintf("generator %s produced artifact with empty path; skipped", r.name))
                continue
            }
            rel := filepath.Clean(a.Path)
            if !opts.Overwrite {
                if prev, exists := pathIndex[rel]; exists {
                    return Result{}, fmt.Errorf("%w: %s (by %s, previously by %s)", ErrDuplicatePath, rel, r.name, prev)
                }
            }
            pathIndex[rel] = r.name
            if a.Mode == 0 {
                a.Mode = DefaultPermissions
            }
            if a.Generator == "" {
                a.Generator = r.name
            }
            artifacts = append(artifacts, a)
        }
    }

    sort.SliceStable(artifacts, func(i, j int) bool { return artifacts[i].Path < artifacts[j].Path })

    h := fnv.New64a()
    for _, a := range artifacts {
        _, _ = h.Write([]byte(a.Path))
        _, _ = h.Write(a.Data)
    }

    return Result{
        Artifacts:     artifacts,
        Diagnostics:   diagnostics,
        Duration:      time.Since(start),
        SchemaVersion: sch.Version(),
        Hash:          h.Sum64(),
    }, nil
}

func generatorTargetsAllowed(g Generator, allowed []Target) bool {
    if len(allowed) == 0 {
        return true
    }
    set := map[Target]struct{}{}
    for _, t := range allowed {
        set[t] = struct{}{}
    }
    for _, t := range g.Targets() {
        if _, ok := set[t]; ok {
            return true
        }
    }
    return false
}

// -----------------------------------------------------------------------------
// Validation
// -----------------------------------------------------------------------------

func ValidateSchema(sch Schema) error {
    if sch == nil {
        return errors.New("schema is nil")
    }
    seen := map[string]struct{}{}
    for _, e := range sch.Entities() {
        n := strings.TrimSpace(e.Name())
        if n == "" {
            return errors.New("entity with empty name")
        }
        if _, ok := seen[n]; ok {
            return fmt.Errorf("duplicate entity name: %s", n)
        }
        seen[n] = struct{}{}
        pkCount := 0
        colSet := map[string]struct{}{}
        for _, f := range e.Fields() {
            if strings.TrimSpace(f.Name()) == "" {
                return fmt.Errorf("entity %s has field with empty name", n)
            }
            col := strings.TrimSpace(firstNonEmpty(f.Column(), toSnakeCase(f.Name())))
            if col == "" {
                return fmt.Errorf("entity %s field %s has empty column", n, f.Name())
            }
            if _, ok := colSet[col]; ok {
                return fmt.Errorf("entity %s has duplicate column: %s", n, col)
            }
            colSet[col] = struct{}{}
            if f.PrimaryKey() {
                pkCount++
            }
        }
        if pkCount == 0 {
            return fmt.Errorf("entity %s has no primary key", n)
        }
    }
    return nil
}

func ValidateOptions(opts Options) error {
    if opts.Newline != "" && opts.Newline != "\n" && opts.Newline != "\r\n" {
        return fmt.Errorf("unsupported newline: %q", opts.Newline)
    }
    return nil
}

// -----------------------------------------------------------------------------
// Helpers (naming, mapping, emit)
// -----------------------------------------------------------------------------

func nl(opts Options) string {
    if opts.Newline == "" {
        return "\n"
    }
    return opts.Newline
}

func indentUnit(opts Options) string {
    if opts.Indent == "" {
        return "  "
    }
    return opts.Indent
}

func firstNonEmpty(vals ...string) string {
    for _, v := range vals {
        if strings.TrimSpace(v) != "" {
            return v
        }
    }
    return ""
}

func splitWords(s string) []string {
    s = strings.TrimSpace(s)
    if s == "" {
        return nil
    }
    sep := func(r rune) bool {
        return r == '_' || r == '-' || r == ' ' || r == '/' || r == '.' || r == ':'
    }
    parts := strings.FieldsFunc(s, sep)
    var out []string
    for _, p := range parts {
        out = append(out, camelChunks(p)...)
    }
    return out
}

func camelChunks(s string) []string {
    if s == "" {
        return nil
    }
    var out []string
    var cur strings.Builder
    var prevCat int // 0 other, 1 upper, 2 lower, 3 digit
    catOf := func(r rune) int {
        switch {
        case r >= 'A' && r <= 'Z':
            return 1
        case r >= 'a' && r <= 'z':
            return 2
        case r >= '0' && r <= '9':
            return 3
        default:
            return 0
        }
    }
    for i, r := range s {
        cat := catOf(r)
        if i > 0 && ((cat == 1 && prevCat == 2) || (cat == 2 && prevCat == 1)) {
            out = append(out, cur.String())
            cur.Reset()
        }
        cur.WriteRune(r)
        prevCat = cat
    }
    if cur.Len() > 0 {
        out = append(out, cur.String())
    }
    return out
}

func toPascalCase(s string) string {
    parts := splitWords(s)
    for i := range parts {
        if parts[i] == "" {
            continue
        }
        parts[i] = strings.ToUpper(parts[i][:1]) + strings.ToLower(parts[i][1:])
    }
    return strings.Join(parts, "")
}

func toCamelCase(s string) string {
    p := toPascalCase(s)
    if p == "" {
        return p
    }
    return strings.ToLower(p[:1]) + p[1:]
}

func toSnakeCase(s string) string {
    parts := splitWords(s)
    for i := range parts {
        parts[i] = strings.ToLower(parts[i])
    }
    return strings.Join(parts, "_")
}

type mappedType struct {
    Go, Py, TS, JS, Java, Cs, Kt, Swift, Dart, PHP, Ruby, Rust, Scala, CPP, SQL, JSON, GQL, Proto string
    IsNumber   bool
    IsInteger  bool
    IsString   bool
    IsBool     bool
    IsDateTime bool
    IsBytes    bool
}

func mapField(f Field) mappedType {
    kind := strings.ToLower(strings.TrimSpace(f.Kind()))
    switch kind {
    case "string":
        return mappedType{
            Go: "string", Py: "str", TS: "string", JS: "string", Java: "String", Cs: "string", Kt: "String",
            Swift: "String", Dart: "String", PHP: "string", Ruby: "String", Rust: "String", Scala: "String",
            CPP: "std::string", SQL: "TEXT", JSON: "string", GQL: "String", Proto: "string", IsString: true,
        }
    case "uuid":
        return mappedType{
            Go: "string", Py: "str", TS: "string", JS: "string", Java: "String", Cs: "string", Kt: "String",
            Swift: "String", Dart: "String", PHP: "string", Ruby: "String", Rust: "String", Scala: "String",
            CPP: "std::string", SQL: "UUID", JSON: "string", GQL: "ID", Proto: "string", IsString: true,
        }
    case "bool", "boolean":
        return mappedType{
            Go: "bool", Py: "bool", TS: "boolean", JS: "boolean", Java: "boolean", Cs: "bool", Kt: "Boolean",
            Swift: "Bool", Dart: "bool", PHP: "bool", Ruby: "Boolean", Rust: "bool", Scala: "Boolean",
            CPP: "bool", SQL: "BOOLEAN", JSON: "boolean", GQL: "Boolean", Proto: "bool", IsBool: true,
        }
    case "int32":
        return mappedType{
            Go: "int32", Py: "int", TS: "number", JS: "number", Java: "int", Cs: "int", Kt: "Int",
            Swift: "Int32", Dart: "int", PHP: "int", Ruby: "Integer", Rust: "i32", Scala: "Int",
            CPP: "int32_t", SQL: "INTEGER", JSON: "integer", GQL: "Int", Proto: "int32", IsInteger: true, IsNumber: true,
        }
    case "int64", "long":
        return mappedType{
            Go: "int64", Py: "int", TS: "number", JS: "number", Java: "long", Cs: "long", Kt: "Long",
            Swift: "Int64", Dart: "int", PHP: "int", Ruby: "Integer", Rust: "i64", Scala: "Long",
            CPP: "int64_t", SQL: "BIGINT", JSON: "integer", GQL: "Int", Proto: "int64", IsInteger: true, IsNumber: true,
        }
    case "float32":
        return mappedType{
            Go: "float32", Py: "float", TS: "number", JS: "number", Java: "float", Cs: "float", Kt: "Float",
            Swift: "Float", Dart: "double", PHP: "float", Ruby: "Float", Rust: "f32", Scala: "Float",
            CPP: "float", SQL: "REAL", JSON: "number", GQL: "Float", Proto: "float", IsNumber: true,
        }
    case "float64", "double":
        return mappedType{
            Go: "float64", Py: "float", TS: "number", JS: "number", Java: "double", Cs: "double", Kt: "Double",
            Swift: "Double", Dart: "double", PHP: "float", Ruby: "Float", Rust: "f64", Scala: "Double",
            CPP: "double", SQL: "DOUBLE PRECISION", JSON: "number", GQL: "Float", Proto: "double", IsNumber: true,
        }
    case "decimal":
        return mappedType{
            Go: "string", Py: "Decimal", TS: "string", JS: "string", Java: "java.math.BigDecimal", Cs: "decimal", Kt: "java.math.BigDecimal",
            Swift: "Decimal", Dart: "String", PHP: "string", Ruby: "BigDecimal", Rust: "String", Scala: "BigDecimal",
            CPP: "std::string", SQL: "DECIMAL", JSON: "string", GQL: "String", Proto: "string",
        }
    case "datetime", "timestamp":
        return mappedType{
            Go: "time.Time", Py: "datetime.datetime", TS: "string", JS: "string", Java: "java.time.OffsetDateTime", Cs: "DateTimeOffset", Kt: "java.time.OffsetDateTime",
            Swift: "Date", Dart: "DateTime", PHP: "DateTimeImmutable", Ruby: "Time", Rust: "String", Scala: "java.time.OffsetDateTime",
            CPP: "std::string", SQL: "TIMESTAMP", JSON: "string", GQL: "DateTime", Proto: "string", IsDateTime: true,
        }
    case "date":
        return mappedType{
            Go: "time.Time", Py: "datetime.date", TS: "string", JS: "string", Java: "java.time.LocalDate", Cs: "DateOnly", Kt: "java.time.LocalDate",
            Swift: "Date", Dart: "DateTime", PHP: "DateTimeImmutable", Ruby: "Date", Rust: "String", Scala: "java.time.LocalDate",
            CPP: "std::string", SQL: "DATE", JSON: "string", GQL: "Date", Proto: "string",
        }
    case "time":
        return mappedType{
            Go: "time.Time", Py: "datetime.time", TS: "string", JS: "string", Java: "java.time.LocalTime", Cs: "TimeOnly", Kt: "java.time.LocalTime",
            Swift: "Date", Dart: "DateTime", PHP: "DateTimeImmutable", Ruby: "Time", Rust: "String", Scala: "java.time.LocalTime",
            CPP: "std::string", SQL: "TIME", JSON: "string", GQL: "Time", Proto: "string",
        }
    case "bytes", "binary":
        return mappedType{
            Go: "[]byte", Py: "bytes", TS: "string", JS: "string", Java: "byte[]", Cs: "byte[]", Kt: "ByteArray",
            Swift: "Data", Dart: "Uint8List", PHP: "string", Ruby: "String", Rust: "Vec<u8>", Scala: "Array[Byte]",
            CPP: "std::vector<uint8_t>", SQL: "BYTEA", JSON: "string", GQL: "String", Proto: "bytes", IsBytes: true,
        }
    case "json", "object", "map":
        return mappedType{
            Go: "map[string]any", Py: "dict", TS: "Record<string, any>", JS: "Object", Java: "java.util.Map<String,Object>", Cs: "Dictionary<string,object>", Kt: "Map<String,Any>",
            Swift: "[String: Any]", Dart: "Map<String, dynamic>", PHP: "array", Ruby: "Hash", Rust: "serde_json::Value", Scala: "Map[String,Any]",
            CPP: "std::string", SQL: "JSON", JSON: "object", GQL: "String", Proto: "string",
        }
    default:
        return mappedType{
            Go: "string", Py: "str", TS: "string", JS: "string", Java: "String", Cs: "string", Kt: "String",
            Swift: "String", Dart: "String", PHP: "string", Ruby: "String", Rust: "String", Scala: "String",
            CPP: "std::string", SQL: "TEXT", JSON: "string", GQL: "String", Proto: "string", IsString: true,
        }
    }
}

func applyNullable(t string, nullable bool, lang Target) string {
    if !nullable {
        return t
    }
    switch lang {
    case TargetGo:
        if strings.HasPrefix(t, "[]") {
            return t
        }
        if t == "time.Time" {
            return "*time.Time"
        }
        if !strings.HasPrefix(t, "*") && t != "any" {
            return "*" + t
        }
        return t
    case TargetJava:
        switch t {
        case "int":
            return "Integer"
        case "long":
            return "Long"
        case "float":
            return "Float"
        case "double":
            return "Double"
        case "boolean":
            return "Boolean"
        default:
            return t
        }
    case TargetCSharp:
        switch t {
        case "int", "long", "float", "double", "bool", "DateTimeOffset":
            return t + "?"
        default:
            return t
        }
    case TargetKotlin:
        return t + "?"
    case TargetSwift:
        return t + "?"
    case TargetDart:
        return t + "?"
    case TargetPHP:
        return "?" + t
    case TargetRust:
        return "Option<" + t + ">"
    case TargetScala:
        return "Option[" + t + "]"
    case TargetCPP:
        return "std::optional<" + t + ">"
    default:
        return t
    }
}

func docCommentLines(doc string) []string {
    lines := strings.Split(strings.ReplaceAll(strings.TrimSpace(doc), "\r\n", "\n"), "\n")
    out := make([]string, 0, len(lines))
    for _, l := range lines {
        l = strings.TrimSpace(l)
        if l != "" {
            out = append(out, l)
        }
    }
    return out
}

func header(opts Options) string {
    var b strings.Builder
    if strings.TrimSpace(opts.Preamble) != "" {
        b.WriteString(opts.Preamble)
        if !strings.HasSuffix(opts.Preamble, "\n") {
            b.WriteString("\n")
        }
    }
    b.WriteString(GeneratedNotice)
    return b.String()
}

func art(path string, data []byte, t Target, gen string) Artifact {
    return Artifact{Path: filepath.Clean(path), Data: data, Mode: DefaultPermissions, Target: t, Generator: gen}
}

func outDirOr(defaultDir, configured string) string {
    if strings.TrimSpace(configured) != "" {
        return configured
    }
    return defaultDir
}

func optIf(cond bool, s string) string {
    if cond {
        return s
    }
    return ""
}

// -----------------------------------------------------------------------------
// Go generator
// -----------------------------------------------------------------------------

type goModelsGenerator struct{}

func (g *goModelsGenerator) Name() string      { return "go-models" }
func (g *goModelsGenerator) Targets() []Target { return []Target{TargetGo} }
func (g *goModelsGenerator) Generate(ctx context.Context, sch Schema, opts Options) ([]Artifact, error) {
    var out []Artifact
    odir := outDirOr("internal/models", opts.OutDir)
    pkg := firstNonEmpty(opts.GoPackage, "models")
    nl := nl(opts)

    for _, e := range sch.Entities() {
        var b bytes.Buffer
        b.WriteString(header(opts))
        if len(opts.GoBuildTags) > 0 {
            b.WriteString("//go:build ")
            b.WriteString(strings.Join(opts.GoBuildTags, " && "))
            b.WriteString(nl + nl)
        }
        b.WriteString("package " + pkg + nl + nl)

        // imports
        hasTime := false
        for _, f := range e.Fields() {
            if mapField(f).Go == "time.Time" {
                hasTime = true
                break
            }
        }
        if hasTime {
            b.WriteString("import \"time\"" + nl + nl)
        }

        name := toPascalCase(e.Name())
        if opts.EmitDocs && strings.TrimSpace(e.Doc()) != "" {
            for _, l := range docCommentLines(e.Doc()) {
                b.WriteString("// " + l + nl)
            }
        }
        b.WriteString("type " + name + " struct {" + nl)
        for _, f := range e.Fields() {
            mt := mapField(f)
            ft := applyNullable(mt.Go, f.Nullable(), TargetGo)
            fieldName := toPascalCase(f.Name())
            jsonTag := toSnakeCase(f.Name())
            tag := fmt.Sprintf("`json:\"%s", jsonTag)
            if opts.OmitEmptyJSON {
                tag += ",omitempty"
            }
            tag += "\"`"
            if opts.EmitDocs && strings.TrimSpace(f.Doc()) != "" {
                for _, l := range docCommentLines(f.Doc()) {
                    b.WriteString(indentUnit(opts) + "// " + l + nl)
                }
            }
            b.WriteString(fmt.Sprintf("%s%s %s %s%s", indentUnit(opts), fieldName, ft, tag, nl))
        }
        b.WriteString("}" + nl)
        path := filepath.Join(odir, strings.ToLower(name)+".gen.go")
        out = append(out, art(path, b.Bytes(), TargetGo, g.Name()))
    }

    // package doc
    {
        var b bytes.Buffer
        b.WriteString(header(opts))
        b.WriteString("package " + pkg + nl)
        out = append(out, art(filepath.Join(odir, "doc.gen.go"), b.Bytes(), TargetGo, g.Name()))
    }

    return out, nil
}

// -----------------------------------------------------------------------------
// Python generator (Pydantic v1-like or dataclass)
// -----------------------------------------------------------------------------

type pyModelsGenerator struct{}

func (g *pyModelsGenerator) Name() string      { return "py-models" }
func (g *pyModelsGenerator) Targets() []Target { return []Target{TargetPy} }
func (g *pyModelsGenerator) Generate(ctx context.Context, sch Schema, opts Options) ([]Artifact, error) {
    var out []Artifact
    base := outDirOr("sdk/python/models", opts.PyModuleBase)
    nl := nl(opts)
    usePydantic := opts.PyUsePydantic

    // __init__.py
    {
        var b bytes.Buffer
        b.WriteString(header(opts))
        if usePydantic {
            b.WriteString("from pydantic import BaseModel" + nl)
        }
        for _, e := range sch.Entities() {
            b.WriteString(fmt.Sprintf("from .%s import %s%s", strings.ToLower(e.Name()), toPascalCase(e.Name()), nl))
        }
        out = append(out, art(filepath.Join(base, "__init__.py"), b.Bytes(), TargetPy, g.Name()))
    }

    for _, e := range sch.Entities() {
        var b bytes.Buffer
        b.WriteString(header(opts))
        name := toPascalCase(e.Name())
        if usePydantic {
            b.WriteString("from pydantic import BaseModel" + nl)
            b.WriteString("from typing import Optional, Dict, Any" + nl + nl)
            if opts.EmitDocs && strings.TrimSpace(e.Doc()) != "" {
                b.WriteString(fmt.Sprintf("\"\"\"%s\"\"\"%s", strings.ReplaceAll(e.Doc(), "\"\"\"", "\"\""), nl))
            }
            b.WriteString("class " + name + "(BaseModel):" + nl)
            if len(e.Fields()) == 0 {
                b.WriteString(indentUnit(opts) + "pass" + nl)
            } else {
                for _, f := range e.Fields() {
                    mt := mapField(f)
                    py := mt.Py
                    if f.Nullable() {
                        py = "Optional[" + py + "]"
                    }
                    line := fmt.Sprintf("%s%s: %s", indentUnit(opts), toSnakeCase(f.Name()), py)
                    if def, ok := f.Default(); ok && strings.TrimSpace(def) != "" {
                        line += " = " + def
                    }
                    b.WriteString(line + nl)
                }
            }
        } else {
            b.WriteString("from dataclasses import dataclass" + nl)
            b.WriteString("from typing import Optional, Dict, Any" + nl + nl)
            b.WriteString("@dataclass" + nl)
            b.WriteString("class " + name + ":" + nl)
            if len(e.Fields()) == 0 {
                b.WriteString(indentUnit(opts) + "pass" + nl)
            } else {
                for _, f := range e.Fields() {
                    mt := mapField(f)
                    py := mt.Py
                    if f.Nullable() {
                        py = "Optional[" + py + "]"
                    }
                    b.WriteString(fmt.Sprintf("%s%s: %s%s", indentUnit(opts), toSnakeCase(f.Name()), py, nl))
                }
            }
        }
        out = append(out, art(filepath.Join(base, strings.ToLower(e.Name())+".py"), b.Bytes(), TargetPy, g.Name()))
    }
    return out, nil
}

// -----------------------------------------------------------------------------
// TypeScript generator
// -----------------------------------------------------------------------------

type tsModelsGenerator struct{}

func (g *tsModelsGenerator) Name() string      { return "ts-models" }
func (g *tsModelsGenerator) Targets() []Target { return []Target{TargetTS} }
func (g *tsModelsGenerator) Generate(ctx context.Context, sch Schema, opts Options) ([]Artifact, error) {
    var out []Artifact
    odir := outDirOr("web/src/models", opts.TSOutDir)
    nl := nl(opts)

    index := bytes.NewBuffer(nil)
    index.WriteString(header(opts))

    for _, e := range sch.Entities() {
        var b bytes.Buffer
        b.WriteString(header(opts))
        name := toPascalCase(e.Name())
        if opts.EmitDocs && strings.TrimSpace(e.Doc()) != "" {
            for _, l := range docCommentLines(e.Doc()) {
                if opts.TSJSDoc {
                    b.WriteString("/** " + l + " */" + nl)
                } else {
                    b.WriteString("// " + l + nl)
                }
            }
        }
        b.WriteString("export interface " + name + " {" + nl)
        for _, f := range e.Fields() {
            mt := mapField(f)
            ts := mt.TS
            opt := ""
            if f.Nullable() {
                opt = "?"
            }
            if opts.EmitDocs && strings.TrimSpace(f.Doc()) != "" {
                if opts.TSJSDoc {
                    for _, l := range docCommentLines(f.Doc()) {
                        b.WriteString(indentUnit(opts) + "/** " + l + " */" + nl)
                    }
                } else {
                    for _, l := range docCommentLines(f.Doc()) {
                        b.WriteString(indentUnit(opts) + "// " + l + nl)
                    }
                }
            }
            b.WriteString(fmt.Sprintf("%s%s%s: %s;%s", indentUnit(opts), toCamelCase(f.Name()), opt, ts, nl))
        }
        b.WriteString("}" + nl)

        fn := strings.ToLower(e.Name()) + ".ts"
        out = append(out, art(filepath.Join(odir, fn), b.Bytes(), TargetTS, g.Name()))
        index.WriteString(fmt.Sprintf("export type { %s } from './%s';%s", name, strings.TrimSuffix(fn, ".ts"), nl))
    }

    out = append(out, art(filepath.Join(odir, "index.ts"), index.Bytes(), TargetTS, g.Name()))
    return out, nil
}

// -----------------------------------------------------------------------------
// JavaScript generator (JSDoc typedefs)
// -----------------------------------------------------------------------------

type jsModelsGenerator struct{}

func (g *jsModelsGenerator) Name() string      { return "js-models" }
func (g *jsModelsGenerator) Targets() []Target { return []Target{TargetJS} }
func (g *jsModelsGenerator) Generate(ctx context.Context, sch Schema, opts Options) ([]Artifact, error) {
    var out []Artifact
    odir := outDirOr("web/js/models", opts.OutDir)
    nl := nl(opts)

    for _, e := range sch.Entities() {
        var b bytes.Buffer
        b.WriteString(header(opts))
        name := toPascalCase(e.Name())
        b.WriteString("/**" + nl)
        b.WriteString(" * @typedef {" + nl)
        for _, f := range e.Fields() {
            mt := mapField(f)
            js := mt.JS
            optional := f.Nullable()
            b.WriteString(fmt.Sprintf(" *   %s%s: %s;%s", toCamelCase(f.Name()), optIf(optional, "?"), js, nl))
        }
        b.WriteString(" * } " + name + nl)
        b.WriteString(" */" + nl)
        path := filepath.Join(odir, strings.ToLower(e.Name())+".js")
        out = append(out, art(path, b.Bytes(), TargetJS, g.Name()))
    }
    return out, nil
}

// -----------------------------------------------------------------------------
// Java generator (simple POJO)
// -----------------------------------------------------------------------------

type javaModelsGenerator struct{}

func (g *javaModelsGenerator) Name() string      { return "java-models" }
func (g *javaModelsGenerator) Targets() []Target { return []Target{TargetJava} }
func (g *javaModelsGenerator) Generate(ctx context.Context, sch Schema, opts Options) ([]Artifact, error) {
    var out []Artifact
    odir := outDirOr("sdk/java/src/main/java", opts.JavaOutDir)
    pkg := firstNonEmpty(opts.JavaPkg, "com.example.models")
    nl := nl(opts)

    for _, e := range sch.Entities() {
        var b bytes.Buffer
        b.WriteString(header(opts))
        b.WriteString("package " + pkg + ";" + nl + nl)

        needsTime := false
        for _, f := range e.Fields() {
            j := mapField(f).Java
            if strings.HasPrefix(j, "java.time.") {
                needsTime = true
                break
            }
        }
        if needsTime {
            b.WriteString("import java.time.*;" + nl)
        }
        name := toPascalCase(e.Name())
        if opts.EmitDocs && strings.TrimSpace(e.Doc()) != "" {
            for _, l := range docCommentLines(e.Doc()) {
                b.WriteString("/** " + l + " */" + nl)
            }
        }
        b.WriteString("public class " + name + " {" + nl)
        for _, f := range e.Fields() {
            mt := mapField(f)
            jt := applyNullable(mt.Java, f.Nullable(), TargetJava)
            b.WriteString(fmt.Sprintf("%sprivate %s %s;%s", indentUnit(opts), jt, toCamelCase(f.Name()), nl))
        }
        b.WriteString(nl)
        for _, f := range e.Fields() {
            mt := mapField(f)
            jt := applyNullable(mt.Java, f.Nullable(), TargetJava)
            field := toCamelCase(f.Name())
            prop := toPascalCase(f.Name())
            b.WriteString(fmt.Sprintf("%spublic %s get%s() { return this.%s; }%s", indentUnit(opts), jt, prop, field, nl))
            b.WriteString(fmt.Sprintf("%spublic void set%s(%s v) { this.%s = v; }%s", indentUnit(opts), prop, jt, field, nl))
        }
        b.WriteString("}" + nl)
        p := filepath.Join(odir, strings.ReplaceAll(pkg, ".", "/"), name+".java")
        out = append(out, art(p, b.Bytes(), TargetJava, g.Name()))
    }
    return out, nil
}

// -----------------------------------------------------------------------------
// C# generator
// -----------------------------------------------------------------------------

type csharpModelsGenerator struct{}

func (g *csharpModelsGenerator) Name() string      { return "csharp-models" }
func (g *csharpModelsGenerator) Targets() []Target { return []Target{TargetCSharp} }
func (g *csharpModelsGenerator) Generate(ctx context.Context, sch Schema, opts Options) ([]Artifact, error) {
    var out []Artifact
    odir := outDirOr("sdk/csharp", opts.CsOutDir)
    ns := firstNonEmpty(opts.CsNs, "Example.Models")
    nl := nl(opts)

    for _, e := range sch.Entities() {
        var b bytes.Buffer
        b.WriteString(header(opts))
        b.WriteString("using System;" + nl + nl)
        b.WriteString("namespace " + ns + " {" + nl)
        name := toPascalCase(e.Name())
        b.WriteString(indentUnit(opts) + "public class " + name + " {" + nl)
        for _, f := range e.Fields() {
            mt := mapField(f)
            ct := applyNullable(mt.Cs, f.Nullable(), TargetCSharp)
            prop := toPascalCase(f.Name())
            b.WriteString(fmt.Sprintf("%s%spublic %s %s { get; set; }%s", indentUnit(opts), indentUnit(opts), ct, prop, nl))
        }
        b.WriteString(indentUnit(opts) + "}" + nl + "}" + nl)
        p := filepath.Join(odir, name+".cs")
        out = append(out, art(p, b.Bytes(), TargetCSharp, g.Name()))
    }
    return out, nil
}

// -----------------------------------------------------------------------------
// Kotlin generator
// -----------------------------------------------------------------------------

type kotlinModelsGenerator struct{}

func (g *kotlinModelsGenerator) Name() string      { return "kotlin-models" }
func (g *kotlinModelsGenerator) Targets() []Target { return []Target{TargetKotlin} }
func (g *kotlinModelsGenerator) Generate(ctx context.Context, sch Schema, opts Options) ([]Artifact, error) {
    var out []Artifact
    odir := outDirOr("sdk/kotlin/src/main/kotlin", opts.KtOutDir)
    pkg := firstNonEmpty(opts.KtPkg, "com.example.models")
    nl := nl(opts)

    for _, e := range sch.Entities() {
        var b bytes.Buffer
        b.WriteString(header(opts))
        b.WriteString("package " + pkg + nl + nl)
        name := toPascalCase(e.Name())
        b.WriteString("data class " + name + "(" + nl)
        for i, f := range e.Fields() {
            mt := mapField(f)
            kt := applyNullable(mt.Kt, f.Nullable(), TargetKotlin)
            sep := ","
            if i == len(e.Fields())-1 {
                sep = ""
            }
            b.WriteString(fmt.Sprintf("%sval %s: %s%s%s", indentUnit(opts), toCamelCase(f.Name()), kt, sep, nl))
        }
        b.WriteString(")" + nl)
        p := filepath.Join(odir, strings.ReplaceAll(pkg, ".", "/"), name+".kt")
        out = append(out, art(p, b.Bytes(), TargetKotlin, g.Name()))
    }
    return out, nil
}

// -----------------------------------------------------------------------------
// Swift generator
// -----------------------------------------------------------------------------

type swiftModelsGenerator struct{}

func (g *swiftModelsGenerator) Name() string      { return "swift-models" }
func (g *swiftModelsGenerator) Targets() []Target { return []Target{TargetSwift} }
func (g *swiftModelsGenerator) Generate(ctx context.Context, sch Schema, opts Options) ([]Artifact, error) {
    var out []Artifact
    odir := outDirOr("sdk/swift/Models", opts.SwiftOutDir)
    nl := nl(opts)

    for _, e := range sch.Entities() {
        var b bytes.Buffer
        b.WriteString(header(opts))
        name := toPascalCase(e.Name())
        b.WriteString("import Foundation" + nl + nl)
        b.WriteString("public struct " + name + ": Codable {" + nl)
        for _, f := range e.Fields() {
            mt := mapField(f)
            sw := applyNullable(mt.Swift, f.Nullable(), TargetSwift)
            b.WriteString(fmt.Sprintf("%spublic var %s: %s%s", indentUnit(opts), toCamelCase(f.Name()), sw, nl))
        }
        b.WriteString("}" + nl)
        p := filepath.Join(odir, name+".swift")
        out = append(out, art(p, b.Bytes(), TargetSwift, g.Name()))
    }
    return out, nil
}

// -----------------------------------------------------------------------------
// Dart generator
// -----------------------------------------------------------------------------

type dartModelsGenerator struct{}

func (g *dartModelsGenerator) Name() string      { return "dart-models" }
func (g *dartModelsGenerator) Targets() []Target { return []Target{TargetDart} }
func (g *dartModelsGenerator) Generate(ctx context.Context, sch Schema, opts Options) ([]Artifact, error) {
    var out []Artifact
    odir := outDirOr("sdk/dart/lib/models", opts.DartOutDir)
    nl := nl(opts)

    for _, e := range sch.Entities() {
        var b bytes.Buffer
        b.WriteString(header(opts))
        name := toPascalCase(e.Name())
        b.WriteString("class " + name + " {" + nl)
        for _, f := range e.Fields() {
            mt := mapField(f)
            dt := applyNullable(mt.Dart, f.Nullable(), TargetDart)
            b.WriteString(fmt.Sprintf("%sfinal %s %s;%s", indentUnit(opts), dt, toCamelCase(f.Name()), nl))
        }
        b.WriteString(nl)
        b.WriteString(indentUnit(opts) + name + "({" + nl)
        for _, f := range e.Fields() {
            opt := ""
            if !f.Nullable() {
                opt = "required "
            }
            b.WriteString(fmt.Sprintf("%s%sthis.%s,%s", strings.Repeat(indentUnit(opts), 2), opt, toCamelCase(f.Name()), nl))
        }
        b.WriteString(indentUnit(opts) + "});" + nl)
        b.WriteString("}" + nl)
        p := filepath.Join(odir, strings.ToLower(e.Name())+".dart")
        out = append(out, art(p, b.Bytes(), TargetDart, g.Name()))
    }
    return out, nil
}

// -----------------------------------------------------------------------------
// PHP generator
// -----------------------------------------------------------------------------

type phpModelsGenerator struct{}

func (g *phpModelsGenerator) Name() string      { return "php-models" }
func (g *phpModelsGenerator) Targets() []Target { return []Target{TargetPHP} }
func (g *phpModelsGenerator) Generate(ctx context.Context, sch Schema, opts Options) ([]Artifact, error) {
    var out []Artifact
    odir := outDirOr("sdk/php", opts.PhpOutDir)
    ns := firstNonEmpty(opts.PhpNs, "Example\\Models")
    nl := nl(opts)

    for _, e := range sch.Entities() {
        var b bytes.Buffer
        b.WriteString(header(opts))
        b.WriteString("<?php" + nl + nl)
        b.WriteString("namespace " + ns + ";" + nl + nl)
        name := toPascalCase(e.Name())
        b.WriteString("class " + name + " {" + nl)
        for _, f := range e.Fields() {
            mt := mapField(f)
            pt := mt.PHP
            if f.Nullable() {
                pt = "?" + pt
            }
            b.WriteString(fmt.Sprintf("%spublic %s $%s;%s", indentUnit(opts), pt, toCamelCase(f.Name()), nl))
        }
        b.WriteString("}" + nl)
        p := filepath.Join(odir, name+".php")
        out = append(out, art(p, b.Bytes(), TargetPHP, g.Name()))
    }
    return out, nil
}

// -----------------------------------------------------------------------------
// Ruby generator
// -----------------------------------------------------------------------------

type rubyModelsGenerator struct{}

func (g *rubyModelsGenerator) Name() string      { return "ruby-models" }
func (g *rubyModelsGenerator) Targets() []Target { return []Target{TargetRuby} }
func (g *rubyModelsGenerator) Generate(ctx context.Context, sch Schema, opts Options) ([]Artifact, error) {
    var out []Artifact
    odir := outDirOr("sdk/ruby/lib/models", opts.RubyOutDir)
    nl := nl(opts)

    for _, e := range sch.Entities() {
        var b bytes.Buffer
        b.WriteString(header(opts))
        name := toPascalCase(e.Name())
        b.WriteString("class " + name + nl)
        if len(e.Fields()) > 0 {
            var names []string
            for _, f := range e.Fields() {
                names = append(names, ":"+toSnakeCase(f.Name()))
            }
            b.WriteString(indentUnit(opts) + "attr_accessor " + strings.Join(names, ", ") + nl)
        }
        b.WriteString("end" + nl)
        p := filepath.Join(odir, strings.ToLower(e.Name())+".rb")
        out = append(out, art(p, b.Bytes(), TargetRuby, g.Name()))
    }
    return out, nil
}

// -----------------------------------------------------------------------------
// Rust generator (serde-friendly)
// -----------------------------------------------------------------------------

type rustModelsGenerator struct{}

func (g *rustModelsGenerator) Name() string      { return "rust-models" }
func (g *rustModelsGenerator) Targets() []Target { return []Target{TargetRust} }
func (g *rustModelsGenerator) Generate(ctx context.Context, sch Schema, opts Options) ([]Artifact, error) {
    var out []Artifact
    odir := outDirOr("sdk/rust/src/models", opts.RustOutDir)
    nl := nl(opts)

    // single file with all models
    var b bytes.Buffer
    b.WriteString(header(opts))
    b.WriteString("use serde::{Serialize, Deserialize};" + nl + nl)
    for _, e := range sch.Entities() {
        name := toPascalCase(e.Name())
        b.WriteString("#[derive(Debug, Clone, Serialize, Deserialize)]" + nl)
        b.WriteString("pub struct " + name + " {" + nl)
        for _, f := range e.Fields() {
            mt := mapField(f)
            rt := mt.Rust
            if f.Nullable() {
                rt = "Option<" + rt + ">"
            }
            b.WriteString(fmt.Sprintf("%spub %s: %s,%s", indentUnit(opts), toSnakeCase(f.Name()), rt, nl))
        }
        b.WriteString("}" + nl + nl)
    }
    out = append(out, art(filepath.Join(filepath.Dir(odir), "models.rs"), b.Bytes(), TargetRust, g.Name()))
    return out, nil
}

// -----------------------------------------------------------------------------
// Scala generator
// -----------------------------------------------------------------------------

type scalaModelsGenerator struct{}

func (g *scalaModelsGenerator) Name() string      { return "scala-models" }
func (g *scalaModelsGenerator) Targets() []Target { return []Target{TargetScala} }
func (g *scalaModelsGenerator) Generate(ctx context.Context, sch Schema, opts Options) ([]Artifact, error) {
    var out []Artifact
    odir := outDirOr("sdk/scala/src/main/scala", opts.ScalaOutDir)
    pkg := firstNonEmpty(opts.ScalaPkg, "example.models")
    nl := nl(opts)

    for _, e := range sch.Entities() {
        var b bytes.Buffer
        b.WriteString(header(opts))
        b.WriteString("package " + pkg + nl + nl)
        name := toPascalCase(e.Name())
        b.WriteString("final case class " + name + "(" + nl)
        for i, f := range e.Fields() {
            mt := mapField(f)
            st := mt.Scala
            if f.Nullable() {
                st = "Option[" + st + "]"
            }
            sep := ","
            if i == len(e.Fields())-1 {
                sep = ""
            }
            b.WriteString(fmt.Sprintf("%s%s: %s%s%s", indentUnit(opts), toCamelCase(f.Name()), st, sep, nl))
        }
        b.WriteString(")" + nl)
        p := filepath.Join(odir, strings.ReplaceAll(pkg, ".", "/"), name+".scala")
        out = append(out, art(p, b.Bytes(), TargetScala, g.Name()))
    }
    return out, nil
}

// -----------------------------------------------------------------------------
// C++ generator (header-only simple struct per entity)
// -----------------------------------------------------------------------------

type cppModelsGenerator struct{}

func (g *cppModelsGenerator) Name() string      { return "cpp-models" }
func (g *cppModelsGenerator) Targets() []Target { return []Target{TargetCPP} }
func (g *cppModelsGenerator) Generate(ctx context.Context, sch Schema, opts Options) ([]Artifact, error) {
    var out []Artifact
    odir := outDirOr("sdk/cpp/include/models", opts.CppOutDir)
    nl := nl(opts)

    ns := firstNonEmpty(opts.CppNs, "models")

    for _, e := range sch.Entities() {
        var b bytes.Buffer
        b.WriteString(header(opts))
        name := toPascalCase(e.Name())
        guard := strings.ToUpper("MODELS_" + name + "_HPP")
        b.WriteString("#pragma once" + nl + nl)
        b.WriteString("#include <string>" + nl + "#include <vector>" + nl + "#include <optional>" + nl + nl)
        b.WriteString("namespace " + ns + " {" + nl)
        b.WriteString("struct " + name + " {" + nl)
        for _, f := range e.Fields() {
            mt := mapField(f)
            cp := mt.CPP
            if f.Nullable() {
                cp = "std::optional<" + cp + ">"
            }
            b.WriteString(fmt.Sprintf("%s%s %s;%s", indentUnit(opts), cp, toCamelCase(f.Name()), nl))
        }
        b.WriteString("};" + nl + "}" + nl)
        p := filepath.Join(odir, name+".hpp")
        _ = guard // guard shown but using pragma once for simplicity
        out = append(out, art(p, b.Bytes(), TargetCPP, g.Name()))
    }
    return out, nil
}

// -----------------------------------------------------------------------------
// SQL DDL generator (simple CREATE TABLE)
// -----------------------------------------------------------------------------

type sqlDDLGenerator struct{}

func (g *sqlDDLGenerator) Name() string      { return "sql-ddl" }
func (g *sqlDDLGenerator) Targets() []Target { return []Target{TargetSQL} }
func (g *sqlDDLGenerator) Generate(ctx context.Context, sch Schema, opts Options) ([]Artifact, error) {
    var out []Artifact
    odir := outDirOr("db/migrations", opts.SQLOutDir)
    nl := nl(opts)

    for _, e := range sch.Entities() {
        var b bytes.Buffer
        b.WriteString("-- " + strings.ReplaceAll(GeneratedNotice, "\n", "") + nl)
        table := firstNonEmpty(e.Table(), toSnakeCase(e.Name()))
        b.WriteString("CREATE TABLE IF NOT EXISTS " + table + " (" + nl)
        var cols []string
        var pks []string
        for _, f := range e.Fields() {
            col := firstNonEmpty(f.Column(), toSnakeCase(f.Name()))
            def := sqlTypeForField(f, opts)
            defs := []string{col, def}
            if !f.Nullable() {
                defs = append(defs, "NOT NULL")
            }
            if f.Unique() {
                defs = append(defs, "UNIQUE")
            }
            if f.PrimaryKey() {
                pks = append(pks, col)
            }
            if d, ok := f.Default(); ok && strings.TrimSpace(d) != "" {
                defs = append(defs, "DEFAULT "+d)
            }
            cols = append(cols, indentUnit(opts)+strings.Join(defs, " "))
        }
        if len(pks) > 0 {
            cols = append(cols, indentUnit(opts)+"PRIMARY KEY ("+strings.Join(pks, ", ")+")")
        }
        b.WriteString(strings.Join(cols, ","+nl) + nl + ");" + nl)
        p := filepath.Join(odir, fmt.Sprintf("create_%s.sql", table))
        out = append(out, art(p, b.Bytes(), TargetSQL, g.Name()))
    }
    return out, nil
}

func sqlTypeForField(f Field, opts Options) string {
    mt := mapField(f)
    switch strings.ToLower(strings.TrimSpace(f.Kind())) {
    case "string":
        if ml, ok := f.MaxLen(); ok && ml > 0 {
            return fmt.Sprintf("VARCHAR(%d)", ml)
        }
        return "TEXT"
    case "uuid":
        if opts.SQLDialect == "mysql" {
            return "CHAR(36)"
        }
        return "UUID"
    case "bool", "boolean":
        return "BOOLEAN"
    case "int32":
        return "INTEGER"
    case "int64", "long":
        return "BIGINT"
    case "float32":
        return "REAL"
    case "float64", "double":
        return "DOUBLE PRECISION"
    case "decimal":
        if s, p, ok := f.ScalePrecision(); ok {
            return fmt.Sprintf("DECIMAL(%d,%d)", p, s)
        }
        return "DECIMAL"
    case "datetime", "timestamp":
        switch opts.SQLDialect {
        case "mysql":
            return "DATETIME"
        default:
            return "TIMESTAMP"
        }
    case "date":
        return "DATE"
    case "time":
        return "TIME"
    case "bytes", "binary":
        switch opts.SQLDialect {
        case "mysql":
            return "LONGBLOB"
        default:
            return "BYTEA"
        }
    case "json", "object", "map":
        if opts.SQLDialect == "mysql" {
            return "JSON"
        }
        return "JSON"
    default:
        return mt.SQL
    }
}

// -----------------------------------------------------------------------------
// JSON Schema generator (Draft-07-ish)
// -----------------------------------------------------------------------------

type jsonSchemaGenerator struct{}

func (g *jsonSchemaGenerator) Name() string      { return "json-schema" }
func (g *jsonSchemaGenerator) Targets() []Target { return []Target{TargetJSON} }
func (g *jsonSchemaGenerator) Generate(ctx context.Context, sch Schema, opts Options) ([]Artifact, error) {
    var out []Artifact
    odir := outDirOr("schemas/json", opts.JSONOutDir)

    indent := opts.JSONIndent
    if indent == "" {
        indent = "  "
    }

    for _, e := range sch.Entities() {
        root := map[string]any{
            "$schema": "http://json-schema.org/draft-07/schema#",
            "title":   toPascalCase(e.Name()),
            "type":    "object",
        }
        props := map[string]any{}
        required := []string{}
        for _, f := range e.Fields() {
            mt := mapField(f)
            p := map[string]any{}
            switch mt.JSON {
            case "string":
                p["type"] = "string"
                if strings.TrimSpace(f.Format()) != "" {
                    p["format"] = f.Format()
                }
                if ml, ok := f.MaxLen(); ok
