{
  "version": 3,
  "sources": ["../../svelte/src/internal/server/errors.js", "../../svelte/src/internal/server/abort-signal.js", "../../svelte/src/internal/server/context.js", "../../svelte/src/internal/server/hydration.js", "../../svelte/src/html-tree-validation.js", "../../svelte/src/internal/server/payload.js", "../../svelte/src/internal/server/dev.js", "../../svelte/src/internal/server/index.js"],
  "sourcesContent": ["/* This file is generated by scripts/process-messages/index.js. Do not edit! */\r\n\r\nexport *  from '../shared/errors.js';\r\n\r\n/**\r\n * `%name%(...)` is not available on the server\r\n * @param {string} name\r\n * @returns {never}\r\n */\r\nexport function lifecycle_function_unavailable(name) {\r\n\tconst error = new Error(`lifecycle_function_unavailable\\n\\`${name}(...)\\` is not available on the server\\nhttps://svelte.dev/e/lifecycle_function_unavailable`);\r\n\r\n\terror.name = 'Svelte error';\r\n\r\n\tthrow error;\r\n}", "import { STALE_REACTION } from '#client/constants';\r\n\r\n/** @type {AbortController | null} */\r\nlet controller = null;\r\n\r\nexport function abort() {\r\n\tcontroller?.abort(STALE_REACTION);\r\n\tcontroller = null;\r\n}\r\n\r\nexport function getAbortSignal() {\r\n\treturn (controller ??= new AbortController()).signal;\r\n}\r\n", "/** @import { Component } from '#server' */\r\nimport { DEV } from 'esm-env';\r\nimport { on_destroy } from './index.js';\r\nimport * as e from './errors.js';\r\n\r\n/** @type {Component | null} */\r\nexport var current_component = null;\r\n\r\n/**\r\n * @template T\r\n * @param {any} key\r\n * @returns {T}\r\n */\r\nexport function getContext(key) {\r\n\tconst context_map = get_or_init_context_map('getContext');\r\n\tconst result = /** @type {T} */ (context_map.get(key));\r\n\r\n\treturn result;\r\n}\r\n\r\n/**\r\n * @template T\r\n * @param {any} key\r\n * @param {T} context\r\n * @returns {T}\r\n */\r\nexport function setContext(key, context) {\r\n\tget_or_init_context_map('setContext').set(key, context);\r\n\treturn context;\r\n}\r\n\r\n/**\r\n * @param {any} key\r\n * @returns {boolean}\r\n */\r\nexport function hasContext(key) {\r\n\treturn get_or_init_context_map('hasContext').has(key);\r\n}\r\n\r\n/** @returns {Map<any, any>} */\r\nexport function getAllContexts() {\r\n\treturn get_or_init_context_map('getAllContexts');\r\n}\r\n\r\n/**\r\n * @param {string} name\r\n * @returns {Map<unknown, unknown>}\r\n */\r\nfunction get_or_init_context_map(name) {\r\n\tif (current_component === null) {\r\n\t\te.lifecycle_outside_component(name);\r\n\t}\r\n\r\n\treturn (current_component.c ??= new Map(get_parent_context(current_component) || undefined));\r\n}\r\n\r\n/**\r\n * @param {Function} [fn]\r\n */\r\nexport function push(fn) {\r\n\tcurrent_component = { p: current_component, c: null, d: null };\r\n\tif (DEV) {\r\n\t\t// component function\r\n\t\tcurrent_component.function = fn;\r\n\t}\r\n}\r\n\r\nexport function pop() {\r\n\tvar component = /** @type {Component} */ (current_component);\r\n\r\n\tvar ondestroy = component.d;\r\n\r\n\tif (ondestroy) {\r\n\t\ton_destroy.push(...ondestroy);\r\n\t}\r\n\r\n\tcurrent_component = component.p;\r\n}\r\n\r\n/**\r\n * @param {Component} component_context\r\n * @returns {Map<unknown, unknown> | null}\r\n */\r\nfunction get_parent_context(component_context) {\r\n\tlet parent = component_context.p;\r\n\r\n\twhile (parent !== null) {\r\n\t\tconst context_map = parent.c;\r\n\t\tif (context_map !== null) {\r\n\t\t\treturn context_map;\r\n\t\t}\r\n\t\tparent = parent.p;\r\n\t}\r\n\r\n\treturn null;\r\n}\r\n", "import { HYDRATION_END, HYDRATION_START, HYDRATION_START_ELSE } from '../../constants.js';\r\n\r\nexport const BLOCK_OPEN = `<!--${HYDRATION_START}-->`;\r\nexport const BLOCK_OPEN_ELSE = `<!--${HYDRATION_START_ELSE}-->`;\r\nexport const BLOCK_CLOSE = `<!--${HYDRATION_END}-->`;\r\nexport const EMPTY_COMMENT = `<!---->`;\r\n", "/**\r\n * Map of elements that have certain elements that are not allowed inside them, in the sense that they will auto-close the parent/ancestor element.\r\n * Theoretically one could take advantage of it but most of the time it will just result in confusing behavior and break when SSR'd.\r\n * There are more elements that are invalid inside other elements, but they're not auto-closed and so don't break SSR and are therefore not listed here.\r\n * @type {Record<string, { direct: string[]} | { descendant: string[]; reset_by?: string[] }>}\r\n */\r\nconst autoclosing_children = {\r\n\t// based on http://developers.whatwg.org/syntax.html#syntax-tag-omission\r\n\tli: { direct: ['li'] },\r\n\t// https://developer.mozilla.org/en-US/docs/Web/HTML/Element/dt#technical_summary\r\n\tdt: { descendant: ['dt', 'dd'], reset_by: ['dl'] },\r\n\tdd: { descendant: ['dt', 'dd'], reset_by: ['dl'] },\r\n\tp: {\r\n\t\tdescendant: [\r\n\t\t\t'address',\r\n\t\t\t'article',\r\n\t\t\t'aside',\r\n\t\t\t'blockquote',\r\n\t\t\t'div',\r\n\t\t\t'dl',\r\n\t\t\t'fieldset',\r\n\t\t\t'footer',\r\n\t\t\t'form',\r\n\t\t\t'h1',\r\n\t\t\t'h2',\r\n\t\t\t'h3',\r\n\t\t\t'h4',\r\n\t\t\t'h5',\r\n\t\t\t'h6',\r\n\t\t\t'header',\r\n\t\t\t'hgroup',\r\n\t\t\t'hr',\r\n\t\t\t'main',\r\n\t\t\t'menu',\r\n\t\t\t'nav',\r\n\t\t\t'ol',\r\n\t\t\t'p',\r\n\t\t\t'pre',\r\n\t\t\t'section',\r\n\t\t\t'table',\r\n\t\t\t'ul'\r\n\t\t]\r\n\t},\r\n\trt: { descendant: ['rt', 'rp'] },\r\n\trp: { descendant: ['rt', 'rp'] },\r\n\toptgroup: { descendant: ['optgroup'] },\r\n\toption: { descendant: ['option', 'optgroup'] },\r\n\tthead: { direct: ['tbody', 'tfoot'] },\r\n\ttbody: { direct: ['tbody', 'tfoot'] },\r\n\ttfoot: { direct: ['tbody'] },\r\n\ttr: { direct: ['tr', 'tbody'] },\r\n\ttd: { direct: ['td', 'th', 'tr'] },\r\n\tth: { direct: ['td', 'th', 'tr'] }\r\n};\r\n\r\n/**\r\n * Returns true if the tag is either the last in the list of siblings and will be autoclosed,\r\n * or not allowed inside the parent tag such that it will auto-close it. The latter results\r\n * in the browser repairing the HTML, which will likely result in an error during hydration.\r\n * @param {string} current\r\n * @param {string} [next]\r\n */\r\nexport function closing_tag_omitted(current, next) {\r\n\tconst disallowed = autoclosing_children[current];\r\n\tif (disallowed) {\r\n\t\tif (\r\n\t\t\t!next ||\r\n\t\t\t('direct' in disallowed ? disallowed.direct : disallowed.descendant).includes(next)\r\n\t\t) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t}\r\n\treturn false;\r\n}\r\n\r\n/**\r\n * Map of elements that have certain elements that are not allowed inside them, in the sense that the browser will somehow repair the HTML.\r\n * There are more elements that are invalid inside other elements, but they're not repaired and so don't break SSR and are therefore not listed here.\r\n * @type {Record<string, { direct: string[]} | { descendant: string[]; reset_by?: string[]; only?: string[] } | { only: string[] }>}\r\n */\r\nconst disallowed_children = {\r\n\t...autoclosing_children,\r\n\toptgroup: { only: ['option', '#text'] },\r\n\t// Strictly speaking, seeing an <option> doesn't mean we're in a <select>, but we assume it here\r\n\toption: { only: ['#text'] },\r\n\tform: { descendant: ['form'] },\r\n\ta: { descendant: ['a'] },\r\n\tbutton: { descendant: ['button'] },\r\n\th1: { descendant: ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'] },\r\n\th2: { descendant: ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'] },\r\n\th3: { descendant: ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'] },\r\n\th4: { descendant: ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'] },\r\n\th5: { descendant: ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'] },\r\n\th6: { descendant: ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'] },\r\n\t// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect\r\n\tselect: { only: ['option', 'optgroup', '#text', 'hr', 'script', 'template'] },\r\n\r\n\t// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd\r\n\t// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption\r\n\t// No special behavior since these rules fall back to \"in body\" mode for\r\n\t// all except special table nodes which cause bad parsing behavior anyway.\r\n\r\n\t// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd\r\n\ttr: { only: ['th', 'td', 'style', 'script', 'template'] },\r\n\t// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody\r\n\ttbody: { only: ['tr', 'style', 'script', 'template'] },\r\n\tthead: { only: ['tr', 'style', 'script', 'template'] },\r\n\ttfoot: { only: ['tr', 'style', 'script', 'template'] },\r\n\t// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup\r\n\tcolgroup: { only: ['col', 'template'] },\r\n\t// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable\r\n\ttable: {\r\n\t\tonly: ['caption', 'colgroup', 'tbody', 'thead', 'tfoot', 'style', 'script', 'template']\r\n\t},\r\n\t// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead\r\n\thead: {\r\n\t\tonly: [\r\n\t\t\t'base',\r\n\t\t\t'basefont',\r\n\t\t\t'bgsound',\r\n\t\t\t'link',\r\n\t\t\t'meta',\r\n\t\t\t'title',\r\n\t\t\t'noscript',\r\n\t\t\t'noframes',\r\n\t\t\t'style',\r\n\t\t\t'script',\r\n\t\t\t'template'\r\n\t\t]\r\n\t},\r\n\t// https://html.spec.whatwg.org/multipage/semantics.html#the-html-element\r\n\thtml: { only: ['head', 'body', 'frameset'] },\r\n\tframeset: { only: ['frame'] },\r\n\t'#document': { only: ['html'] }\r\n};\r\n\r\n/**\r\n * Returns an error message if the tag is not allowed inside the ancestor tag (which is grandparent and above) such that it will result\r\n * in the browser repairing the HTML, which will likely result in an error during hydration.\r\n * @param {string} child_tag\r\n * @param {string[]} ancestors All nodes starting with the parent, up until the ancestor, which means two entries minimum\r\n * @param {string} [child_loc]\r\n * @param {string} [ancestor_loc]\r\n * @returns {string | null}\r\n */\r\nexport function is_tag_valid_with_ancestor(child_tag, ancestors, child_loc, ancestor_loc) {\r\n\tif (child_tag.includes('-')) return null; // custom elements can be anything\r\n\r\n\tconst ancestor_tag = ancestors[ancestors.length - 1];\r\n\tconst disallowed = disallowed_children[ancestor_tag];\r\n\tif (!disallowed) return null;\r\n\r\n\tif ('reset_by' in disallowed && disallowed.reset_by) {\r\n\t\tfor (let i = ancestors.length - 2; i >= 0; i--) {\r\n\t\t\tconst ancestor = ancestors[i];\r\n\t\t\tif (ancestor.includes('-')) return null; // custom elements can be anything\r\n\r\n\t\t\t// A reset means that forbidden descendants are allowed again\r\n\t\t\tif (disallowed.reset_by.includes(ancestors[i])) {\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tif ('descendant' in disallowed && disallowed.descendant.includes(child_tag)) {\r\n\t\tconst child = child_loc ? `\\`<${child_tag}>\\` (${child_loc})` : `\\`<${child_tag}>\\``;\r\n\t\tconst ancestor = ancestor_loc\r\n\t\t\t? `\\`<${ancestor_tag}>\\` (${ancestor_loc})`\r\n\t\t\t: `\\`<${ancestor_tag}>\\``;\r\n\r\n\t\treturn `${child} cannot be a descendant of ${ancestor}`;\r\n\t}\r\n\r\n\treturn null;\r\n}\r\n\r\n/**\r\n * Returns an error message if the tag is not allowed inside the parent tag such that it will result\r\n * in the browser repairing the HTML, which will likely result in an error during hydration.\r\n * @param {string} child_tag\r\n * @param {string} parent_tag\r\n * @param {string} [child_loc]\r\n * @param {string} [parent_loc]\r\n * @returns {string | null}\r\n */\r\nexport function is_tag_valid_with_parent(child_tag, parent_tag, child_loc, parent_loc) {\r\n\tif (child_tag.includes('-') || parent_tag?.includes('-')) return null; // custom elements can be anything\r\n\r\n\tif (parent_tag === 'template') return null; // no errors or warning should be thrown in immediate children of template tags\r\n\r\n\tconst disallowed = disallowed_children[parent_tag];\r\n\r\n\tconst child = child_loc ? `\\`<${child_tag}>\\` (${child_loc})` : `\\`<${child_tag}>\\``;\r\n\tconst parent = parent_loc ? `\\`<${parent_tag}>\\` (${parent_loc})` : `\\`<${parent_tag}>\\``;\r\n\r\n\tif (disallowed) {\r\n\t\tif ('direct' in disallowed && disallowed.direct.includes(child_tag)) {\r\n\t\t\treturn `${child} cannot be a direct child of ${parent}`;\r\n\t\t}\r\n\r\n\t\tif ('descendant' in disallowed && disallowed.descendant.includes(child_tag)) {\r\n\t\t\treturn `${child} cannot be a child of ${parent}`;\r\n\t\t}\r\n\r\n\t\tif ('only' in disallowed && disallowed.only) {\r\n\t\t\tif (disallowed.only.includes(child_tag)) {\r\n\t\t\t\treturn null;\r\n\t\t\t} else {\r\n\t\t\t\treturn `${child} cannot be a child of ${parent}. \\`<${parent_tag}>\\` only allows these children: ${disallowed.only.map((d) => `\\`<${d}>\\``).join(', ')}`;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// These tags are only valid with a few parents that have special child\r\n\t// parsing rules - if we're down here, then none of those matched and\r\n\t// so we allow it only if we don't know what the parent is, as all other\r\n\t// cases are invalid (and we only get into this function if we know the parent).\r\n\tswitch (child_tag) {\r\n\t\tcase 'body':\r\n\t\tcase 'caption':\r\n\t\tcase 'col':\r\n\t\tcase 'colgroup':\r\n\t\tcase 'frameset':\r\n\t\tcase 'frame':\r\n\t\tcase 'head':\r\n\t\tcase 'html':\r\n\t\t\treturn `${child} cannot be a child of ${parent}`;\r\n\t\tcase 'thead':\r\n\t\tcase 'tbody':\r\n\t\tcase 'tfoot':\r\n\t\t\treturn `${child} must be the child of a \\`<table>\\`, not a ${parent}`;\r\n\t\tcase 'td':\r\n\t\tcase 'th':\r\n\t\t\treturn `${child} must be the child of a \\`<tr>\\`, not a ${parent}`;\r\n\t\tcase 'tr':\r\n\t\t\treturn `\\`<tr>\\` must be the child of a \\`<thead>\\`, \\`<tbody>\\`, or \\`<tfoot>\\`, not a ${parent}`;\r\n\t}\r\n\r\n\treturn null;\r\n}\r\n", "export class HeadPayload {\r\n\t/** @type {Set<{ hash: string; code: string }>} */\r\n\tcss = new Set();\r\n\t/** @type {string[]} */\r\n\tout = [];\r\n\tuid = () => '';\r\n\ttitle = '';\r\n\r\n\tconstructor(\r\n\t\t/** @type {Set<{ hash: string; code: string }>} */ css = new Set(),\r\n\t\t/** @type {string[]} */ out = [],\r\n\t\ttitle = '',\r\n\t\tuid = () => ''\r\n\t) {\r\n\t\tthis.css = css;\r\n\t\tthis.out = out;\r\n\t\tthis.title = title;\r\n\t\tthis.uid = uid;\r\n\t}\r\n}\r\n\r\nexport class Payload {\r\n\t/** @type {Set<{ hash: string; code: string }>} */\r\n\tcss = new Set();\r\n\t/** @type {string[]} */\r\n\tout = [];\r\n\tuid = () => '';\r\n\tselect_value = undefined;\r\n\r\n\thead = new HeadPayload();\r\n\r\n\tconstructor(id_prefix = '') {\r\n\t\tthis.uid = props_id_generator(id_prefix);\r\n\t\tthis.head.uid = this.uid;\r\n\t}\r\n}\r\n\r\n/**\r\n * Used in legacy mode to handle bindings\r\n * @param {Payload} to_copy\r\n * @returns {Payload}\r\n */\r\nexport function copy_payload({ out, css, head, uid }) {\r\n\tconst payload = new Payload();\r\n\r\n\tpayload.out = [...out];\r\n\tpayload.css = new Set(css);\r\n\tpayload.uid = uid;\r\n\r\n\tpayload.head = new HeadPayload();\r\n\tpayload.head.out = [...head.out];\r\n\tpayload.head.css = new Set(head.css);\r\n\tpayload.head.title = head.title;\r\n\tpayload.head.uid = head.uid;\r\n\r\n\treturn payload;\r\n}\r\n\r\n/**\r\n * Assigns second payload to first\r\n * @param {Payload} p1\r\n * @param {Payload} p2\r\n * @returns {void}\r\n */\r\nexport function assign_payload(p1, p2) {\r\n\tp1.out = [...p2.out];\r\n\tp1.css = p2.css;\r\n\tp1.head = p2.head;\r\n\tp1.uid = p2.uid;\r\n}\r\n\r\n/**\r\n * Creates an ID generator\r\n * @param {string} prefix\r\n * @returns {() => string}\r\n */\r\nfunction props_id_generator(prefix) {\r\n\tlet uid = 1;\r\n\treturn () => `${prefix}s${uid++}`;\r\n}\r\n", "/** @import { Component } from '#server' */\r\nimport { FILENAME } from '../../constants.js';\r\nimport {\r\n\tis_tag_valid_with_ancestor,\r\n\tis_tag_valid_with_parent\r\n} from '../../html-tree-validation.js';\r\nimport { current_component } from './context.js';\r\nimport * as e from './errors.js';\r\nimport { HeadPayload, Payload } from './payload.js';\r\n\r\n/**\r\n * @typedef {{\r\n * \ttag: string;\r\n * \tparent: null | Element;\r\n *  filename: null | string;\r\n *  line: number;\r\n *  column: number;\r\n * }} Element\r\n */\r\n\r\n/**\r\n * @type {Element | null}\r\n */\r\nlet parent = null;\r\n\r\n/** @type {Set<string>} */\r\nlet seen;\r\n\r\n/**\r\n * @param {Payload} payload\r\n * @param {string} message\r\n */\r\nfunction print_error(payload, message) {\r\n\tmessage =\r\n\t\t`node_invalid_placement_ssr: ${message}\\n\\n` +\r\n\t\t'This can cause content to shift around as the browser repairs the HTML, and will likely result in a `hydration_mismatch` warning.';\r\n\r\n\tif ((seen ??= new Set()).has(message)) return;\r\n\tseen.add(message);\r\n\r\n\t// eslint-disable-next-line no-console\r\n\tconsole.error(message);\r\n\tpayload.head.out.push(`<script>console.error(${JSON.stringify(message)})</script>`);\r\n}\r\n\r\nexport function reset_elements() {\r\n\tlet old_parent = parent;\r\n\tparent = null;\r\n\treturn () => {\r\n\t\tparent = old_parent;\r\n\t};\r\n}\r\n\r\n/**\r\n * @param {Payload} payload\r\n * @param {string} tag\r\n * @param {number} line\r\n * @param {number} column\r\n */\r\nexport function push_element(payload, tag, line, column) {\r\n\tvar filename = /** @type {Component} */ (current_component).function[FILENAME];\r\n\tvar child = { tag, parent, filename, line, column };\r\n\r\n\tif (parent !== null) {\r\n\t\tvar ancestor = parent.parent;\r\n\t\tvar ancestors = [parent.tag];\r\n\r\n\t\tconst child_loc = filename ? `${filename}:${line}:${column}` : undefined;\r\n\t\tconst parent_loc = parent.filename\r\n\t\t\t? `${parent.filename}:${parent.line}:${parent.column}`\r\n\t\t\t: undefined;\r\n\r\n\t\tconst message = is_tag_valid_with_parent(tag, parent.tag, child_loc, parent_loc);\r\n\t\tif (message) print_error(payload, message);\r\n\r\n\t\twhile (ancestor != null) {\r\n\t\t\tancestors.push(ancestor.tag);\r\n\t\t\tconst ancestor_loc = ancestor.filename\r\n\t\t\t\t? `${ancestor.filename}:${ancestor.line}:${ancestor.column}`\r\n\t\t\t\t: undefined;\r\n\r\n\t\t\tconst message = is_tag_valid_with_ancestor(tag, ancestors, child_loc, ancestor_loc);\r\n\t\t\tif (message) print_error(payload, message);\r\n\r\n\t\t\tancestor = ancestor.parent;\r\n\t\t}\r\n\t}\r\n\r\n\tparent = child;\r\n}\r\n\r\nexport function pop_element() {\r\n\tparent = /** @type {Element} */ (parent).parent;\r\n}\r\n\r\n/**\r\n * @param {Payload} payload\r\n */\r\nexport function validate_snippet_args(payload) {\r\n\tif (\r\n\t\ttypeof payload !== 'object' ||\r\n\t\t// for some reason typescript consider the type of payload as never after the first instanceof\r\n\t\t!(payload instanceof Payload || /** @type {any} */ (payload) instanceof HeadPayload)\r\n\t) {\r\n\t\te.invalid_snippet_arguments();\r\n\t}\r\n}\r\n", "/** @import { ComponentType, SvelteComponent } from 'svelte' */\r\n/** @import { Component, RenderOutput } from '#server' */\r\n/** @import { Store } from '#shared' */\r\nexport { FILENAME, HMR } from '../../constants.js';\r\nimport { attr, clsx, to_class, to_style } from '../shared/attributes.js';\r\nimport { is_promise, noop } from '../shared/utils.js';\r\nimport { subscribe_to_store } from '../../store/utils.js';\r\nimport {\r\n\tUNINITIALIZED,\r\n\tELEMENT_PRESERVE_ATTRIBUTE_CASE,\r\n\tELEMENT_IS_NAMESPACED\r\n} from '../../constants.js';\r\nimport { escape_html } from '../../escaping.js';\r\nimport { DEV } from 'esm-env';\r\nimport { current_component, pop, push } from './context.js';\r\nimport { EMPTY_COMMENT, BLOCK_CLOSE, BLOCK_OPEN, BLOCK_OPEN_ELSE } from './hydration.js';\r\nimport { validate_store } from '../shared/validate.js';\r\nimport { is_boolean_attribute, is_raw_text_element, is_void } from '../../utils.js';\r\nimport { reset_elements } from './dev.js';\r\nimport { Payload } from './payload.js';\r\nimport { abort } from './abort-signal.js';\r\n\r\n// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\r\n// https://infra.spec.whatwg.org/#noncharacter\r\nconst INVALID_ATTR_NAME_CHAR_REGEX =\r\n\t/[\\s'\">/=\\u{FDD0}-\\u{FDEF}\\u{FFFE}\\u{FFFF}\\u{1FFFE}\\u{1FFFF}\\u{2FFFE}\\u{2FFFF}\\u{3FFFE}\\u{3FFFF}\\u{4FFFE}\\u{4FFFF}\\u{5FFFE}\\u{5FFFF}\\u{6FFFE}\\u{6FFFF}\\u{7FFFE}\\u{7FFFF}\\u{8FFFE}\\u{8FFFF}\\u{9FFFE}\\u{9FFFF}\\u{AFFFE}\\u{AFFFF}\\u{BFFFE}\\u{BFFFF}\\u{CFFFE}\\u{CFFFF}\\u{DFFFE}\\u{DFFFF}\\u{EFFFE}\\u{EFFFF}\\u{FFFFE}\\u{FFFFF}\\u{10FFFE}\\u{10FFFF}]/u;\r\n\r\n/**\r\n * @param {Payload} payload\r\n * @param {string} tag\r\n * @param {() => void} attributes_fn\r\n * @param {() => void} children_fn\r\n * @returns {void}\r\n */\r\nexport function element(payload, tag, attributes_fn = noop, children_fn = noop) {\r\n\tpayload.out.push('<!---->');\r\n\r\n\tif (tag) {\r\n\t\tpayload.out.push(`<${tag}`);\r\n\t\tattributes_fn();\r\n\t\tpayload.out.push(`>`);\r\n\r\n\t\tif (!is_void(tag)) {\r\n\t\t\tchildren_fn();\r\n\t\t\tif (!is_raw_text_element(tag)) {\r\n\t\t\t\tpayload.out.push(EMPTY_COMMENT);\r\n\t\t\t}\r\n\t\t\tpayload.out.push(`</${tag}>`);\r\n\t\t}\r\n\t}\r\n\r\n\tpayload.out.push('<!---->');\r\n}\r\n\r\n/**\r\n * Array of `onDestroy` callbacks that should be called at the end of the server render function\r\n * @type {Function[]}\r\n */\r\nexport let on_destroy = [];\r\n\r\n/**\r\n * Only available on the server and when compiling with the `server` option.\r\n * Takes a component and returns an object with `body` and `head` properties on it, which you can use to populate the HTML when server-rendering your app.\r\n * @template {Record<string, any>} Props\r\n * @param {import('svelte').Component<Props> | ComponentType<SvelteComponent<Props>>} component\r\n * @param {{ props?: Omit<Props, '$$slots' | '$$events'>; context?: Map<any, any>; idPrefix?: string }} [options]\r\n * @returns {RenderOutput}\r\n */\r\nexport function render(component, options = {}) {\r\n\ttry {\r\n\t\tconst payload = new Payload(options.idPrefix ? options.idPrefix + '-' : '');\r\n\r\n\t\tconst prev_on_destroy = on_destroy;\r\n\t\ton_destroy = [];\r\n\t\tpayload.out.push(BLOCK_OPEN);\r\n\r\n\t\tlet reset_reset_element;\r\n\r\n\t\tif (DEV) {\r\n\t\t\t// prevent parent/child element state being corrupted by a bad render\r\n\t\t\treset_reset_element = reset_elements();\r\n\t\t}\r\n\r\n\t\tif (options.context) {\r\n\t\t\tpush();\r\n\t\t\t/** @type {Component} */ (current_component).c = options.context;\r\n\t\t}\r\n\r\n\t\t// @ts-expect-error\r\n\t\tcomponent(payload, options.props ?? {}, {}, {});\r\n\r\n\t\tif (options.context) {\r\n\t\t\tpop();\r\n\t\t}\r\n\r\n\t\tif (reset_reset_element) {\r\n\t\t\treset_reset_element();\r\n\t\t}\r\n\r\n\t\tpayload.out.push(BLOCK_CLOSE);\r\n\t\tfor (const cleanup of on_destroy) cleanup();\r\n\t\ton_destroy = prev_on_destroy;\r\n\r\n\t\tlet head = payload.head.out.join('') + payload.head.title;\r\n\r\n\t\tfor (const { hash, code } of payload.css) {\r\n\t\t\thead += `<style id=\"${hash}\">${code}</style>`;\r\n\t\t}\r\n\r\n\t\tconst body = payload.out.join('');\r\n\r\n\t\treturn {\r\n\t\t\thead,\r\n\t\t\thtml: body,\r\n\t\t\tbody: body\r\n\t\t};\r\n\t} finally {\r\n\t\tabort();\r\n\t}\r\n}\r\n\r\n/**\r\n * @param {Payload} payload\r\n * @param {(head_payload: Payload['head']) => void} fn\r\n * @returns {void}\r\n */\r\nexport function head(payload, fn) {\r\n\tconst head_payload = payload.head;\r\n\thead_payload.out.push(BLOCK_OPEN);\r\n\tfn(head_payload);\r\n\thead_payload.out.push(BLOCK_CLOSE);\r\n}\r\n\r\n/**\r\n * @param {Payload} payload\r\n * @param {boolean} is_html\r\n * @param {Record<string, string>} props\r\n * @param {() => void} component\r\n * @param {boolean} dynamic\r\n * @returns {void}\r\n */\r\nexport function css_props(payload, is_html, props, component, dynamic = false) {\r\n\tconst styles = style_object_to_string(props);\r\n\r\n\tif (is_html) {\r\n\t\tpayload.out.push(`<svelte-css-wrapper style=\"display: contents; ${styles}\">`);\r\n\t} else {\r\n\t\tpayload.out.push(`<g style=\"${styles}\">`);\r\n\t}\r\n\r\n\tif (dynamic) {\r\n\t\tpayload.out.push('<!---->');\r\n\t}\r\n\r\n\tcomponent();\r\n\r\n\tif (is_html) {\r\n\t\tpayload.out.push(`<!----></svelte-css-wrapper>`);\r\n\t} else {\r\n\t\tpayload.out.push(`<!----></g>`);\r\n\t}\r\n}\r\n\r\n/**\r\n * @param {Record<string, unknown>} attrs\r\n * @param {string | null} css_hash\r\n * @param {Record<string, boolean>} [classes]\r\n * @param {Record<string, string>} [styles]\r\n * @param {number} [flags]\r\n * @returns {string}\r\n */\r\nexport function spread_attributes(attrs, css_hash, classes, styles, flags = 0) {\r\n\tif (styles) {\r\n\t\tattrs.style = to_style(attrs.style, styles);\r\n\t}\r\n\r\n\tif (attrs.class) {\r\n\t\tattrs.class = clsx(attrs.class);\r\n\t}\r\n\r\n\tif (css_hash || classes) {\r\n\t\tattrs.class = to_class(attrs.class, css_hash, classes);\r\n\t}\r\n\r\n\tlet attr_str = '';\r\n\tlet name;\r\n\r\n\tconst is_html = (flags & ELEMENT_IS_NAMESPACED) === 0;\r\n\tconst lowercase = (flags & ELEMENT_PRESERVE_ATTRIBUTE_CASE) === 0;\r\n\r\n\tfor (name in attrs) {\r\n\t\t// omit functions, internal svelte properties and invalid attribute names\r\n\t\tif (typeof attrs[name] === 'function') continue;\r\n\t\tif (name[0] === '$' && name[1] === '$') continue; // faster than name.startsWith('$$')\r\n\t\tif (INVALID_ATTR_NAME_CHAR_REGEX.test(name)) continue;\r\n\r\n\t\tvar value = attrs[name];\r\n\r\n\t\tif (lowercase) {\r\n\t\t\tname = name.toLowerCase();\r\n\t\t}\r\n\r\n\t\tattr_str += attr(name, value, is_html && is_boolean_attribute(name));\r\n\t}\r\n\r\n\treturn attr_str;\r\n}\r\n\r\n/**\r\n * @param {Record<string, unknown>[]} props\r\n * @returns {Record<string, unknown>}\r\n */\r\nexport function spread_props(props) {\r\n\t/** @type {Record<string, unknown>} */\r\n\tconst merged_props = {};\r\n\tlet key;\r\n\r\n\tfor (let i = 0; i < props.length; i++) {\r\n\t\tconst obj = props[i];\r\n\t\tfor (key in obj) {\r\n\t\t\tconst desc = Object.getOwnPropertyDescriptor(obj, key);\r\n\t\t\tif (desc) {\r\n\t\t\t\tObject.defineProperty(merged_props, key, desc);\r\n\t\t\t} else {\r\n\t\t\t\tmerged_props[key] = obj[key];\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn merged_props;\r\n}\r\n\r\n/**\r\n * @param {unknown} value\r\n * @returns {string}\r\n */\r\nexport function stringify(value) {\r\n\treturn typeof value === 'string' ? value : value == null ? '' : value + '';\r\n}\r\n\r\n/** @param {Record<string, string>} style_object */\r\nfunction style_object_to_string(style_object) {\r\n\treturn Object.keys(style_object)\r\n\t\t.filter(/** @param {any} key */ (key) => style_object[key] != null && style_object[key] !== '')\r\n\t\t.map(/** @param {any} key */ (key) => `${key}: ${escape_html(style_object[key], true)};`)\r\n\t\t.join(' ');\r\n}\r\n\r\n/**\r\n * @param {any} value\r\n * @param {string | undefined} [hash]\r\n * @param {Record<string, boolean>} [directives]\r\n */\r\nexport function attr_class(value, hash, directives) {\r\n\tvar result = to_class(value, hash, directives);\r\n\treturn result ? ` class=\"${escape_html(result, true)}\"` : '';\r\n}\r\n\r\n/**\r\n * @param {any} value\r\n * @param {Record<string,any>|[Record<string,any>,Record<string,any>]} [directives]\r\n */\r\nexport function attr_style(value, directives) {\r\n\tvar result = to_style(value, directives);\r\n\treturn result ? ` style=\"${escape_html(result, true)}\"` : '';\r\n}\r\n\r\n/**\r\n * @template V\r\n * @param {Record<string, [any, any, any]>} store_values\r\n * @param {string} store_name\r\n * @param {Store<V> | null | undefined} store\r\n * @returns {V}\r\n */\r\nexport function store_get(store_values, store_name, store) {\r\n\tif (DEV) {\r\n\t\tvalidate_store(store, store_name.slice(1));\r\n\t}\r\n\r\n\t// it could be that someone eagerly updates the store in the instance script, so\r\n\t// we should only reuse the store value in the template\r\n\tif (store_name in store_values && store_values[store_name][0] === store) {\r\n\t\treturn store_values[store_name][2];\r\n\t}\r\n\r\n\tstore_values[store_name]?.[1](); // if store was switched, unsubscribe from old store\r\n\tstore_values[store_name] = [store, null, undefined];\r\n\tconst unsub = subscribe_to_store(\r\n\t\tstore,\r\n\t\t/** @param {any} v */ (v) => (store_values[store_name][2] = v)\r\n\t);\r\n\tstore_values[store_name][1] = unsub;\r\n\treturn store_values[store_name][2];\r\n}\r\n\r\n/**\r\n * Sets the new value of a store and returns that value.\r\n * @template V\r\n * @param {Store<V>} store\r\n * @param {V} value\r\n * @returns {V}\r\n */\r\nexport function store_set(store, value) {\r\n\tstore.set(value);\r\n\treturn value;\r\n}\r\n\r\n/**\r\n * Updates a store with a new value.\r\n * @template V\r\n * @param {Record<string, [any, any, any]>} store_values\r\n * @param {string} store_name\r\n * @param {Store<V>} store\r\n * @param {any} expression\r\n */\r\nexport function store_mutate(store_values, store_name, store, expression) {\r\n\tstore_set(store, store_get(store_values, store_name, store));\r\n\treturn expression;\r\n}\r\n\r\n/**\r\n * @param {Record<string, [any, any, any]>} store_values\r\n * @param {string} store_name\r\n * @param {Store<number>} store\r\n * @param {1 | -1} [d]\r\n * @returns {number}\r\n */\r\nexport function update_store(store_values, store_name, store, d = 1) {\r\n\tlet store_value = store_get(store_values, store_name, store);\r\n\tstore.set(store_value + d);\r\n\treturn store_value;\r\n}\r\n\r\n/**\r\n * @param {Record<string, [any, any, any]>} store_values\r\n * @param {string} store_name\r\n * @param {Store<number>} store\r\n * @param {1 | -1} [d]\r\n * @returns {number}\r\n */\r\nexport function update_store_pre(store_values, store_name, store, d = 1) {\r\n\tconst value = store_get(store_values, store_name, store) + d;\r\n\tstore.set(value);\r\n\treturn value;\r\n}\r\n\r\n/** @param {Record<string, [any, any, any]>} store_values */\r\nexport function unsubscribe_stores(store_values) {\r\n\tfor (const store_name in store_values) {\r\n\t\tstore_values[store_name][1]();\r\n\t}\r\n}\r\n\r\n/**\r\n * @param {Payload} payload\r\n * @param {Record<string, any>} $$props\r\n * @param {string} name\r\n * @param {Record<string, unknown>} slot_props\r\n * @param {null | (() => void)} fallback_fn\r\n * @returns {void}\r\n */\r\nexport function slot(payload, $$props, name, slot_props, fallback_fn) {\r\n\tvar slot_fn = $$props.$$slots?.[name];\r\n\t// Interop: Can use snippets to fill slots\r\n\tif (slot_fn === true) {\r\n\t\tslot_fn = $$props[name === 'default' ? 'children' : name];\r\n\t}\r\n\r\n\tif (slot_fn !== undefined) {\r\n\t\tslot_fn(payload, slot_props);\r\n\t} else {\r\n\t\tfallback_fn?.();\r\n\t}\r\n}\r\n\r\n/**\r\n * @param {Record<string, unknown>} props\r\n * @param {string[]} rest\r\n * @returns {Record<string, unknown>}\r\n */\r\nexport function rest_props(props, rest) {\r\n\t/** @type {Record<string, unknown>} */\r\n\tconst rest_props = {};\r\n\tlet key;\r\n\tfor (key in props) {\r\n\t\tif (!rest.includes(key)) {\r\n\t\t\trest_props[key] = props[key];\r\n\t\t}\r\n\t}\r\n\treturn rest_props;\r\n}\r\n\r\n/**\r\n * @param {Record<string, unknown>} props\r\n * @returns {Record<string, unknown>}\r\n */\r\nexport function sanitize_props(props) {\r\n\tconst { children, $$slots, ...sanitized } = props;\r\n\treturn sanitized;\r\n}\r\n\r\n/**\r\n * @param {Record<string, any>} props\r\n * @returns {Record<string, boolean>}\r\n */\r\nexport function sanitize_slots(props) {\r\n\t/** @type {Record<string, boolean>} */\r\n\tconst sanitized = {};\r\n\tif (props.children) sanitized.default = true;\r\n\tfor (const key in props.$$slots) {\r\n\t\tsanitized[key] = true;\r\n\t}\r\n\treturn sanitized;\r\n}\r\n\r\n/**\r\n * Legacy mode: If the prop has a fallback and is bound in the\r\n * parent component, propagate the fallback value upwards.\r\n * @param {Record<string, unknown>} props_parent\r\n * @param {Record<string, unknown>} props_now\r\n */\r\nexport function bind_props(props_parent, props_now) {\r\n\tfor (const key in props_now) {\r\n\t\tconst initial_value = props_parent[key];\r\n\t\tconst value = props_now[key];\r\n\t\tif (\r\n\t\t\tinitial_value === undefined &&\r\n\t\t\tvalue !== undefined &&\r\n\t\t\tObject.getOwnPropertyDescriptor(props_parent, key)?.set\r\n\t\t) {\r\n\t\t\tprops_parent[key] = value;\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/**\r\n * @template V\r\n * @param {Payload} payload\r\n * @param {Promise<V>} promise\r\n * @param {null | (() => void)} pending_fn\r\n * @param {(value: V) => void} then_fn\r\n * @returns {void}\r\n */\r\nfunction await_block(payload, promise, pending_fn, then_fn) {\r\n\tif (is_promise(promise)) {\r\n\t\tpayload.out.push(BLOCK_OPEN);\r\n\t\tpromise.then(null, noop);\r\n\t\tif (pending_fn !== null) {\r\n\t\t\tpending_fn();\r\n\t\t}\r\n\t} else if (then_fn !== null) {\r\n\t\tpayload.out.push(BLOCK_OPEN_ELSE);\r\n\t\tthen_fn(promise);\r\n\t}\r\n}\r\n\r\nexport { await_block as await };\r\n\r\n/** @param {any} array_like_or_iterator */\r\nexport function ensure_array_like(array_like_or_iterator) {\r\n\tif (array_like_or_iterator) {\r\n\t\treturn array_like_or_iterator.length !== undefined\r\n\t\t\t? array_like_or_iterator\r\n\t\t\t: Array.from(array_like_or_iterator);\r\n\t}\r\n\treturn [];\r\n}\r\n\r\n/**\r\n * @param {any[]} args\r\n * @param {Function} [inspect]\r\n */\r\n// eslint-disable-next-line no-console\r\nexport function inspect(args, inspect = console.log) {\r\n\tinspect('init', ...args);\r\n}\r\n\r\n/**\r\n * @template V\r\n * @param {() => V} get_value\r\n */\r\nexport function once(get_value) {\r\n\tlet value = /** @type {V} */ (UNINITIALIZED);\r\n\treturn () => {\r\n\t\tif (value === UNINITIALIZED) {\r\n\t\t\tvalue = get_value();\r\n\t\t}\r\n\t\treturn value;\r\n\t};\r\n}\r\n\r\n/**\r\n * Create an unique ID\r\n * @param {Payload} payload\r\n * @returns {string}\r\n */\r\nexport function props_id(payload) {\r\n\tconst uid = payload.uid();\r\n\tpayload.out.push('<!--#' + uid + '-->');\r\n\treturn uid;\r\n}\r\n\r\nexport { attr, clsx };\r\n\r\nexport { html } from './blocks/html.js';\r\n\r\nexport { push, pop } from './context.js';\r\n\r\nexport { push_element, pop_element, validate_snippet_args } from './dev.js';\r\n\r\nexport { assign_payload, copy_payload } from './payload.js';\r\n\r\nexport { snapshot } from '../shared/clone.js';\r\n\r\nexport { fallback, to_array } from '../shared/utils.js';\r\n\r\nexport {\r\n\tinvalid_default_snippet,\r\n\tvalidate_dynamic_element_tag,\r\n\tvalidate_void_dynamic_element,\r\n\tprevent_snippet_stringification\r\n} from '../shared/validate.js';\r\n\r\nexport { escape_html as escape };\r\n\r\nexport { await_outside_boundary } from '../shared/errors.js';\r\n\r\n/**\r\n * @template T\r\n * @param {()=>T} fn\r\n * @returns {(new_value?: T) => (T | void)}\r\n */\r\nexport function derived(fn) {\r\n\tconst get_value = once(fn);\r\n\t/**\r\n\t * @type {T | undefined}\r\n\t */\r\n\tlet updated_value;\r\n\r\n\treturn function (new_value) {\r\n\t\tif (arguments.length === 0) {\r\n\t\t\treturn updated_value ?? get_value();\r\n\t\t}\r\n\t\tupdated_value = new_value;\r\n\t\treturn updated_value;\r\n\t};\r\n}\r\n\r\n/**\r\n *\r\n * @param {Payload} payload\r\n * @param {*} value\r\n */\r\nexport function maybe_selected(payload, value) {\r\n\treturn value === payload.select_value ? ' selected' : '';\r\n}\r\n\r\n/**\r\n * @param {Payload} payload\r\n * @param {() => void} children\r\n * @returns {void}\r\n */\r\nexport function valueless_option(payload, children) {\r\n\tvar i = payload.out.length;\r\n\r\n\tchildren();\r\n\r\n\tvar body = payload.out.slice(i).join('');\r\n\r\n\tif (body.replace(/<!---->/g, '') === payload.select_value) {\r\n\t\t// replace '>' with ' selected>' (closing tag will be added later)\r\n\t\tvar last_item = payload.out[i - 1];\r\n\t\tpayload.out[i - 1] = last_item.slice(0, -1) + ' selected>';\r\n\t\t// Remove the old items after position i and add the body as a single item\r\n\t\tpayload.out.splice(i, payload.out.length - i, body);\r\n\t}\r\n}\r\n"],
  "mappings": "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",
  "names": ["parent", "hash"]
}
